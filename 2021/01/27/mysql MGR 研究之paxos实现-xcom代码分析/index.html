<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
    Mysql Mgr模块研究之孟子协议实现：xcom模块 |  babalalala
  </title>
  <meta name="generator" content="hexo-theme-yilia-plus">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/css/style.css">

  
<script src="/js/pace.min.js"></script>


  

  

<link rel="alternate" href="/atom.xml" title="babalalala" type="application/atom+xml">
</head>

</html>

<body>
  <div id="app">
    <main class="content">
      <section class="outer">
  <article id="post-mysql MGR 研究之paxos实现-xcom代码分析" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  Mysql Mgr模块研究之孟子协议实现：xcom模块
</h1>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2021/01/27/mysql%20MGR%20%E7%A0%94%E7%A9%B6%E4%B9%8Bpaxos%E5%AE%9E%E7%8E%B0-xcom%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/" class="article-date">
  <time datetime="2021-01-27T08:55:32.219Z" itemprop="datePublished">2021-01-27</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/distributed-system/">distributed system</a>
  </div>

      
      
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">17.7k字</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">75分钟</span>
        </span>
    </span>
</div>

      
    </div>
    

    
    
    <div class="tocbot"></div>





    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>xcom是MGR中实现一致性协议的核心模块，借鉴Mencius算法的思想实现了一套类paxos协议。xcom首先通过GCS接受到MGR封装的事务消息，然后后通过paxos协议在各个节点上达成一致，最终发送再发送给上层MGR。因此MGR中与xcom相关的模块主要包括与GCS的交互接口，xcom的核心模块paxos实现。在xcom中，首先实现了一套协程机制，xcom所有过程都使用这套协程机制。因此，本文主要介绍一下与上层MGR的交互过程，paxos协议的实现，协程机制的实现，最后看一下paxos各个过程如何通过这套协程实现。</p>
<h2 id="1-与上层MGR的交互"><a href="#1-与上层MGR的交互" class="headerlink" title="1. 与上层MGR的交互"></a>1. 与上层MGR的交互</h2><p>MGR中的事务以Paxos请求的方式发送给xcom，Paxos通过两阶段协议（propose、accept）或者三阶段的(prepare、propose、accept)方式使各节点达成一致后返回给MGR在进行后续处理。</p>
<p>在Gcs_xcom_communication::send_message()接口中会将消息类型设置为Gcs_internal_message_header::CT_USER_DATA，交由 Gcs_xcom_proxy_impl::xcom_client_send_data()发送。</p>
<p>xcom_client_send_data 将事务消息放入m_xcom_input_queue(无锁MPSC队列)中，然后通过与xcom的socket连接，通知xcom模块有消息进入队列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">bool Gcs_xcom_proxy_impl::xcom_client_send_data(unsigned long long len,</span><br><span class="line">                                                char *data) &#123;</span><br><span class="line">  &#x2F;* We own data. *&#x2F;</span><br><span class="line">  </span><br><span class="line">  ....</span><br><span class="line">  </span><br><span class="line">  if (len &lt;&#x3D; std::numeric_limits&lt;unsigned int&gt;::max()) &#123;</span><br><span class="line">    assert(len &gt; 0);</span><br><span class="line">    app_data_ptr msg &#x3D; new_app_data();</span><br><span class="line">    &#x2F;* Takes ownership of data. *&#x2F;</span><br><span class="line">    msg &#x3D; init_app_msg(msg, data, static_cast&lt;uint32_t&gt;(len));</span><br><span class="line">    successful &#x3D; xcom_input_try_push(msg)&#123;</span><br><span class="line">        </span><br><span class="line">        m_xcom_input_queue.push(data);  &#x2F;&#x2F; 将消息放入MGR向xcom发送消息的缓冲队列</span><br><span class="line">        if (pushed) successful &#x3D; ::xcom_input_signal(); &#x2F;&#x2F; 通过tcp通知xcom模块缓冲队列中存入了数据</span><br><span class="line">        return successful;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (!successful) &#123;</span><br><span class="line">      MYSQL_GCS_LOG_DEBUG(&quot;xcom_client_send_data: Failed to push into XCom.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在xcom中，通过本地协程local_server,等待socket请求的到来，然后从m_xcom_input_queue队列中读取消息，调用dispatch_op进行处理，对于op为client_msg的消息，dispatch_op会进一步调用handle_client_msg()插入到prop_input_queue请求channel的末尾。每个MGR节点的Xcom有一个proposer_task，会获取prop_input_queue头部的请求，然后进入paxos的流程。</p>
<p>local_server的主要过程如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int local_server(task_arg arg) &#123;</span><br><span class="line">    .....</span><br><span class="line">     while (!xcom_shutdown) &#123;</span><br><span class="line">        &#x2F;* 等待客户端信号，以便可以从m_xcom_input_queue中读取数据. *&#x2F;</span><br><span class="line">        TASK_CALL(task_read(&amp;ep-&gt;rfd, ep-&gt;buf, 1024, &amp;ep-&gt;nr_read));</span><br><span class="line">        ep-&gt;request &#x3D; xcom_try_pop_from_input_cb();</span><br><span class="line">        while (ep-&gt;request !&#x3D; NULL) &#123;</span><br><span class="line">            ....</span><br><span class="line">            dispatch_op(NULL, ep-&gt;request_pax_msg, &amp;ep-&gt;internal_reply_queue);</span><br><span class="line">            ....</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>xcom中的executor_task会按序获取已经完成Paxos处理流程的事务请求，调用execute_msg()执行该请求，对于app_type类型的请求，会调用deliver_to_app()，该函数最终调用了在MGR初始化时注册的xcom_data_receiver处理函数cb_xcom_receive_data()，发送到上层客户端(GCS)。</p>
<p>下面主要介绍一下事务消息在xcom模块中的处理过程，即paxos的实现。</p>
<h2 id="2-paxos核心协议流程-ing"><a href="#2-paxos核心协议流程-ing" class="headerlink" title="2. paxos核心协议流程(ing)"></a>2. paxos核心协议流程(ing)</h2><h3 id="Mencius协议回顾"><a href="#Mencius协议回顾" class="headerlink" title="Mencius协议回顾"></a>Mencius协议回顾</h3><h4 id="basic-paxos"><a href="#basic-paxos" class="headerlink" title="basic paxos"></a>basic paxos</h4><p><img src="https://img-blog.csdnimg.cn/2020122914594029.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI4MjU4OTAz,size_16,color_FFFFFF,t_70" alt="basic paxos"></p>
<ul>
<li>multi paxos：集群中设置leader节点，可以跳过prepare阶段(变成两阶段)；leader故障时走basic paxos 协议的过程(三阶段)。<h4 id="多领导者"><a href="#多领导者" class="headerlink" title="多领导者"></a>多领导者</h4></li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20201102195424666.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI4MjU4OTAz,size_16,color_FFFFFF,t_70#pic_center" alt="image"></p>
<h4 id="simple-paxos"><a href="#simple-paxos" class="headerlink" title="simple paxos"></a>simple paxos</h4><ul>
<li>coordinator(leader)：在自己负责的日志序列中对应位置，可以提议客户端请求和no-op操作</li>
<li>非 coordinator：只能提议no-op</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20201029203916286.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI4MjU4OTAz,size_16,color_FFFFFF,t_70#pic_center" alt="image"></p>
<h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><ul>
<li><p>将no-op消息piggyback到accept阶段</p>
</li>
<li><p>将no-op消息piggyback到未来的propose阶段</p>
<p><img src="https://img-blog.csdnimg.cn/20201029203955265.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI4MjU4OTAz,size_16,color_FFFFFF,t_70#pic_center" alt="image"></p>
</li>
</ul>
<p>目前xcom模块已经实现了Mencius算法中的paxos和simple paxos部分，但由于Mencius算法中优化算法依赖于异步的FIFO通信机制(Asynchronous FIFO communication channel)来保证正确性，因此xcom中并没有实现。</p>
<h3 id="2-1-主要数据结构"><a href="#2-1-主要数据结构" class="headerlink" title="2.1 主要数据结构"></a>2.1 主要数据结构</h3><p>在xcom模块中比较重要的数据结构如下：</p>
<p>struct site_def 描述了一个有时效性的MGR/Paxos集群配置,每个节点维护了一个唯一的site_def对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 描述了一个有时效性的MGR&#x2F;Paxos集群配置,每个节点维护了一个site_def对象</span><br><span class="line">struct site_def &#123;</span><br><span class="line">  synode_no start;    &#x2F;* Config is active from this message number *&#x2F;</span><br><span class="line">  synode_no boot_key; &#x2F;* The message number of the original unified_boot *&#x2F;</span><br><span class="line">  node_no nodeno;     &#x2F;* Node number of this node *&#x2F;</span><br><span class="line">  node_list nodes;    &#x2F;* Set of nodes in this config *&#x2F;</span><br><span class="line">  server *servers[NSERVERS]; &#x2F;* Connections to other nodes *&#x2F;</span><br><span class="line">  detector_state detected;   &#x2F;* Time of last incoming message for each node *&#x2F;</span><br><span class="line">  node_no global_node_count; &#x2F;* Number of live nodes in global_node_set *&#x2F;</span><br><span class="line">  node_set global_node_set;  &#x2F;* The global view *&#x2F;</span><br><span class="line">  node_set local_node_set;   &#x2F;* The local view *&#x2F;</span><br><span class="line">  int detector_updated;      &#x2F;* Has detector state been updated? *&#x2F;</span><br><span class="line">  xcom_proto x_proto;</span><br><span class="line">  synode_no delivered_msg[NSERVERS];</span><br><span class="line">  double install_time;</span><br><span class="line">  xcom_event_horizon event_horizon;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>主要内容包括集群节点生效的开始消息编号，本节点的编号，在当前视图配置下节点的编号，当前视图中节点的集合，与本节点保持连接的节点，每个节点最新的消息发送时间，全局视图中节点的数量及集合，本节点视图中节点的数量及集合，与正常的paxos协议执行相关的字段包括servers和delivered_msg。前者维护了本节点到集群中其他节点的连接，后者表现各个节点的消息完成状态。</p>
<p>经过paxos处理的消息都有一个消息号synode_no。nodeno是节点在Paxos集群中的序号，该序号是Paxos消息synode_no的组成部分，synode_no的另一部分为消息序号，结合在一起synode_no表现为{X, N}，其中X为消息序号，N为节点序号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct synode_no &#123;</span><br><span class="line">	uint32_t group_id; &#x2F;&#x2F; 用于判断新加入的节点是否是同一个组，MGR节点间交互通过xcom进行，而MGR规定的不同组不能构成集群的要求，只能在xcom中实现</span><br><span class="line">	uint64_t msgno;</span><br><span class="line">	node_no node;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int synode_gt(synode_no x, synode_no y) &#123;</span><br><span class="line">  assert(x.group_id &#x3D;&#x3D; 0 || y.group_id &#x3D;&#x3D; 0 || x.group_id &#x3D;&#x3D; y.group_id);</span><br><span class="line">  return (x.msgno &gt; y.msgno) || (x.msgno &#x3D;&#x3D; y.msgno &amp;&amp; x.node &gt; y.node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20201230114950546.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI4MjU4OTAz,size_16,color_FFFFFF,t_70" alt="image"></p>
<p>在进行prepare、propose、accept和learn等Paxos操作时，需要依赖site_def中的server对象发送消息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Server definition *&#x2F;</span><br><span class="line">struct server &#123;</span><br><span class="line">  int garbage;</span><br><span class="line">  int refcnt;</span><br><span class="line">  char *srv;                 &#x2F;* Server name *&#x2F;</span><br><span class="line">  xcom_port port;            &#x2F;* Port *&#x2F;</span><br><span class="line">  connection_descriptor con; &#x2F;* Descriptor for open connection,本节点到指定节点的长连接 *&#x2F;</span><br><span class="line">  double active;             &#x2F;* Last activity *&#x2F;</span><br><span class="line">  double detected;           &#x2F;* Last incoming *&#x2F;</span><br><span class="line">  channel outgoing;          &#x2F;* Outbound messages *&#x2F;</span><br><span class="line">  task_env *sender;          &#x2F;* The sender task *&#x2F;</span><br><span class="line">  task_env *reply_handler;   &#x2F;* The reply task *&#x2F;</span><br><span class="line">  srv_buf out_buf;</span><br><span class="line">  int invalid;</span><br><span class="line">  int number_of_pings_received; &#x2F;* Number of pings received from this server *&#x2F;</span><br><span class="line">  double last_ping_received;    &#x2F;* Last received ping timestamp *&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>跟消息发送相关的字段主要有：srv是server指向节点的名称，con维护了本节点到server指向节点的长连接，outgoing队列用于缓存本节点需发送到server指向节点的消息，sender是在server初始化时注册的sender_task协程，用来负责从outgoing队列中读取消息发送到server指向节点。在Paxos正常运行期间，server对象是集群中节点间消息发送的媒介，通过con建立2个节点间的联系，发送端即为sender字段对应的sender_task协程，接收端就是server对应节点上的acceptor_learner_task协程。需要注意的是，本节点也会为自己创建一个server对象，此时sener字段即为local_sender_task。</p>
<p>server维护了Paxos集群各节点间的通信管道，pax_msg就是管道中传输的消息。其定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">struct pax_msg&#123;</span><br><span class="line">  node_no to;             &#x2F;* To node *&#x2F;</span><br><span class="line">  node_no from;           &#x2F;* From node *&#x2F;</span><br><span class="line">  uint32_t group_id; &#x2F;* Unique ID shared by our group *&#x2F;</span><br><span class="line">  synode_no max_synode; &#x2F;* Gossip about the max real synode *&#x2F;</span><br><span class="line">  start_t start_type; &#x2F;* Boot or recovery? DEPRECATED *&#x2F;</span><br><span class="line">  ballot reply_to;    &#x2F;* Reply to which ballot *&#x2F;</span><br><span class="line">  ballot proposal;    &#x2F;* Proposal number *&#x2F;</span><br><span class="line">  pax_op op;          &#x2F;* Opcode: prepare, propose, learn, etc *&#x2F;</span><br><span class="line">  synode_no synode;   &#x2F;* The message number *&#x2F;</span><br><span class="line">  pax_msg_type msg_type; &#x2F;* normal, noop, or multi_noop *&#x2F;</span><br><span class="line">  bit_set *receivers;</span><br><span class="line">  app_data *a;      &#x2F;* Payload *&#x2F;</span><br><span class="line">  snapshot *snap;	&#x2F;* Not used *&#x2F;</span><br><span class="line">  gcs_snapshot *gcs_snap; &#x2F;* gcs_snapshot if op &#x3D;&#x3D; gcs_snapshot_op *&#x2F;</span><br><span class="line">  client_reply_code cli_err;</span><br><span class="line">  bool force_delivery; &#x2F;* Deliver this message even if we do not have majority *&#x2F;</span><br><span class="line">  int32_t refcnt;</span><br><span class="line">  synode_no delivered_msg;</span><br><span class="line">  xcom_event_horizon event_horizon;  </span><br><span class="line">  synode_app_data_array requested_synode_app_data;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>


<p>from和to字段标识了消息的源节点和目标节点，to字段可能为null，表示发往所有节点；op标识消息的操作类型，比如是prepare还是propose消息；synode表示该消息的序号，类型为synode_no，消息组成详见site_def定义；msg_type表示消息类型，是普通消息还是不携带数据的noop消息等；receivers表示有多少节点已经接收到了该消息；a是消息数据，比如对于事务消息，该字段就包含了一系列的log_event。reply_to和proposal是2个ballot，ballot由一个节点序号nodeno和计数器cnt组成，表示某次投票号，显然proposal字段表示本次消息提案的投票号，reply_to表示本次消息是对reply_to对应的提案编号的回复。同个pax_msg的proposal和reply_to字段对应的ballot可能不同，举个例子，A节点向B节点发送prepare消息，B节点收到后，发现本节点已经接受了对应synode的消息，那么B节点在回复A消息时，会将消息中的propsal字段设置为本节点的提案编号并替换掉消息体。ballot是Paxos算法强相关的字段，对于某个确定的synode消息，在prepare阶段，一个节点只能继续处理比其之前收到的所有提案编号更大的提案，在acceptor阶段，一个节点只能处理不小于其之前收到的所有提案编号的提案。</p>
<p>在节点上，pax_msg保存在pax_machine中，在Paxos算法中，pax_machine就是一个Paxos实例，即Mencius算法中的instance，对应一条Paxos日志，一系列有序的Paxos日志组成了Paxos状态机。每个节点维护了一个最小5万个pax_machine对象的缓存（paxos cache），有专门的缓存管理协程cache_manager_task负责维持缓冲区的大小在合理范围内。如果节点上所有pax_machine的缓存大小超过了阈值，就会开始清理无用的pax_machine。淘汰算法采用lru机制，不能清理还未走完Paxos协议的pax_machine。pax_machine定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Definition of a Paxos instance *&#x2F;</span><br><span class="line">struct pax_machine &#123;</span><br><span class="line">  linkage hash_link; &#x2F;&#x2F; 在hash表桶中的位置</span><br><span class="line">  stack_machine *stack_link; &#x2F;&#x2F;指向hash_stack中的stack_machine</span><br><span class="line">  lru_machine *lru; &#x2F;&#x2F; 指向当前节点的paxos cache中的LRU缓存</span><br><span class="line">  synode_no synode;</span><br><span class="line">  double last_modified; &#x2F;* Start time *&#x2F;</span><br><span class="line">  linkage rv; &#x2F;*  系统中的睡眠协程队列，本字段主要用于将协程挂到这个队列上，和一个协程执行完成后，唤醒睡眠的协程 *&#x2F;</span><br><span class="line"></span><br><span class="line">  struct &#123;</span><br><span class="line">    ballot bal;            &#x2F;* The current ballot we are working on *&#x2F;</span><br><span class="line">    bit_set *prep_nodeset; &#x2F;* Nodes which have answered my prepare *&#x2F;</span><br><span class="line">    ballot sent_prop;      &#x2F;&#x2F; 记录响应本节点的消息中号码最大的消息</span><br><span class="line">    bit_set *prop_nodeset; &#x2F;* Nodes which have answered my propose *&#x2F;</span><br><span class="line">    pax_msg *msg;          &#x2F;* The value we are trying to push *&#x2F;</span><br><span class="line">    ballot sent_learn;</span><br><span class="line">  &#125; proposer;</span><br><span class="line"></span><br><span class="line">  struct &#123;</span><br><span class="line">    ballot promise; &#x2F;* Promise to not accept any proposals less than this *&#x2F;</span><br><span class="line">    pax_msg *msg;   &#x2F;* The value we have accepted *&#x2F;</span><br><span class="line">  &#125; acceptor;</span><br><span class="line"></span><br><span class="line">  struct &#123;</span><br><span class="line">    pax_msg *msg; &#x2F;* The value we have learned *&#x2F;</span><br><span class="line">  &#125; learner;</span><br><span class="line">  int lock; &#x2F;* 本条pax machine 对应的锁, 其实是一个标志位，标记本条pax machine对象是否正在被使用，比如处于使用状态的pax machine 不能被cache管理协程回收*&#x2F;</span><br><span class="line">  pax_op op;</span><br><span class="line">  int force_delivery;</span><br><span class="line">  int enforcer;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct ballot &#123;</span><br><span class="line">	int32_t cnt;</span><br><span class="line">	node_no node;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>前三个字段与缓存相关。synode标识了该pax_machine处理的消息序号。在MGR中，一个消息/提案是以异步的方式走完Paxos协议，发起投票的proposer_task会在rv字段上等待并周期性被唤醒，直到该提案完成。op表示消息操作类型。proposer、acceptor和learner分别保存了消息序号为synode的提案从本节点视角看到的不同阶段的状态。proposer字段是提案的发起者维护的字段，accetor和learner不会操作proposer字段。MGR中的Paxos实现支持2阶段(multi-paxos)和3阶段(basic paxos)协议，相比2阶段，3阶段协议多了一个prepare的过程。MGR对于正常的事务消息采用2阶段的方式。所以proposer字段包括了prepare和propose 2个阶段，其中bal表示目前的提案编号，prep_nodeset和prop_nodeset分别表示已经回复prepare和propose消息的节点集；sent_prop和sent_learn分别在收到大多数节点回复prepare和propose消息时设置，设置为bal；msg字段在proposer_task进行pax_machine初始化时被置为等待投票的客户端消息，如果有其他节点回复的prepare消息中携带的proposal大于proposer节点的ballot，那么msg会被替换为回复消息对应的pax_msg对象，即投票的value发生改变。acceptor字段由作为提案接受者的节点维护，保存了本节点至今已收到的消息编号为synode的最大ballot，msg字段为对应ballot携带的pax_msg。learner字段表示编号为synode的消息最终被学习的消息体/value。显然，该字段不为空表示对应synode已经完成了Paxos协议。</p>
<h3 id="2-2-paxos协议：Mencius算法实现"><a href="#2-2-paxos协议：Mencius算法实现" class="headerlink" title="2.2 paxos协议：Mencius算法实现"></a>2.2 paxos协议：Mencius算法实现</h3><h4 id="2-2-1-basic-paxos协议过程"><a href="#2-2-1-basic-paxos协议过程" class="headerlink" title="2.2.1 basic paxos协议过程"></a>2.2.1 basic paxos协议过程</h4><p>正常事务处理时的流程也即paxos协议的流程，paxos协议主要分为三个阶段：prepare，propose，accept。</p>
<p><img src="https://img-blog.csdnimg.cn/20201229113215824.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI4MjU4OTAz,size_16,color_FFFFFF,t_70" alt="basic paxos协议流程"></p>
<p><strong>proposer_task</strong></p>
<p>prepare和propose会通过proposer_task协程发起，当xcom模块接受到上层客户端发送来的事务消息时，会被放入prop_input_queue队列中，proposer_task会循环的从队列中获取消息，并对普通的事务消息进行batch操作。而对于视图或者配置变更消息，则不能进行batch。当事务被batch以后，会进行消息的propose操作，典型的paxos协议需要三个阶段，而具有leader的paxos协议只需要两阶段。具有leader节点的paxos协议在正常消息提议时只需要走两阶段，但是当被检测leader故障等情况下需要走三阶段过程。在proposer_task中，会不停的尝试提议消息，直到消息在整个集群中达成一致。</p>
<p>由于paxos整个过程从proposer_task开始，proposer_task中还负责待提议消息号赋值和对应pax machine的获取。<br>主要逻辑如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">static int proposer_task(task_arg arg) &#123;</span><br><span class="line">    while (!xcom_shutdown)&#123;</span><br><span class="line">        &#x2F;&#x2F; 从prop_input_queue队列中取出消息，存入client_msg中</span><br><span class="line">        CHANNEL_GET(&amp;prop_input_queue, &amp;ep-&gt;client_msg, msg_link); &#x2F;&#x2F; ep为当前协程的上下文特征，即栈数据</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 对消息进行batch</span><br><span class="line">        while (AUTOBATCH &amp;&amp; ep-&gt;size &lt;&#x3D; MAX_BATCH_SIZE &amp;&amp;</span><br><span class="line">                ep-&gt;nr_batched_app_data &lt;&#x3D; MAX_BATCH_APP_DATA &amp;&amp;</span><br><span class="line">                !link_empty(&amp;prop_input_queue.data))&#123;</span><br><span class="line">                </span><br><span class="line">                msg_link *tmp;</span><br><span class="line">                app_data_ptr atmp;</span><br><span class="line">                CHANNEL_GET(&amp;prop_input_queue, &amp;tmp, msg_link);              </span><br><span class="line">                atmp &#x3D; tmp-&gt;p-&gt;a;</span><br><span class="line">                &#x2F;&#x2F; 对于视图或者配置变更信息，不可以被batch</span><br><span class="line">                if (is_config(atmp-&gt;body.c_t) || is_view(atmp-&gt;body.c_t) ||</span><br><span class="line">                    ep-&gt;nr_batched_app_data &gt; MAX_BATCH_APP_DATA ||</span><br><span class="line">                    ep-&gt;size &gt; MAX_BATCH_SIZE) &#123;</span><br><span class="line">                    channel_put_front(&amp;prop_input_queue, &amp;tmp-&gt;l);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                ep-&gt;client_msg-&gt;p-&gt;a &#x3D; atmp;</span><br><span class="line">                                  </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ep-&gt;msgno &#x3D; current_message;  &#x2F;&#x2F; 初始化消息号，current_message代表了本节点下一个可用的消息号，每当一个消息被提交到上层MGR时都会更新current_message</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 直到要发送的消息在paxos中达成一致，否则不停的propose</span><br><span class="line">        for (;;) &#123; </span><br><span class="line">            &#x2F;&#x2F; 从状态机pax machine缓存获取一个实例，用于发送GCS上层发过来的客户端消息，最长等待60s</span><br><span class="line">            TASK_CALL(wait_for_cache(&amp;ep-&gt;p, ep-&gt;msgno, 60));</span><br><span class="line">            </span><br><span class="line">            当自身配置为三阶段提交或者需要force_delivery(如发生配置变更)或者其他节点在等待本节点时超时所以提出了no-op，并且本节点已经accept了，那么就需要三阶段提交</span><br><span class="line">            if (threephase || ep-&gt;p-&gt;force_delivery || ep-&gt;p-&gt;acceptor.promise.cnt) &#123;</span><br><span class="line">                push_msg_3p(ep-&gt;site, ep-&gt;p, ep-&gt;prepare_msg, ep-&gt;msgno, normal);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                push_msg_2p(ep-&gt;site, ep-&gt;p);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F; Try to get a value accepted</span><br><span class="line">             while (!finished(ep-&gt;p)) &#123;</span><br><span class="line">                </span><br><span class="line">                &#x2F;&#x2F; 周期性的睡眠等待和醒来</span><br><span class="line">                TIMED_TASK_WAIT(&amp;ep-&gt;p-&gt;rv, ep-&gt;delay &#x3D; wakeup_delay(ep-&gt;delay))；</span><br><span class="line">                &#x2F;&#x2F; 判断该pax_machine是否已经走完learn阶段或者如果在本次propose过程中已经得到了一个被提议了一个值，break；</span><br><span class="line">                if (finished(ep-&gt;p)) break;</span><br><span class="line">                push_msg_3p(ep-&gt;site, ep-&gt;p, ep-&gt;prepare_msg, ep-&gt;msgno, normal); &#x2F;&#x2F; 否则，继续走三阶段阶段</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 检测本次提议最终获得的值是不是本节点想propose的值</span><br><span class="line">            if (match_my_msg(ep-&gt;p-&gt;learner.msg, ep-&gt;client_msg-&gt;p)) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125; else&#123; &#x2F;&#x2F; 如果不是，进行重试，继续尝试提议本次想要提议的消息</span><br><span class="line">                GOTO(retry_new);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>prepare：</strong></p>
<p>在三阶段过程中，首先进行prepare，根据paxos协议，prepare准备提议一个消息，并从整个集群中得知已经被accept的最大提议号的消息。在prepare阶段只带有本次的提议号，不带有消息。主要过如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">static void push_msg_3p(site_def const *site, pax_machine *p, pax_msg *msg,</span><br><span class="line">                        synode_no msgno, pax_msg_type msg_type) &#123;</span><br><span class="line">  if (wait_forced_config) &#123;</span><br><span class="line">    force_pax_machine(p, 1);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  assert(msgno.msgno !&#x3D; 0);</span><br><span class="line">  </span><br><span class="line">  BIT_ZERO(p-&gt;proposer.prep_nodeset); &#x2F;&#x2F; 清空已经回复本节点发出的prepare消息的所有节点</span><br><span class="line">  p-&gt;proposer.bal.node &#x3D; get_nodeno(site); &#x2F;&#x2F; 获取本节点的node号</span><br><span class="line">  &#123;</span><br><span class="line">    int maxcnt &#x3D; MAX(p-&gt;proposer.bal.cnt, p-&gt;acceptor.promise.cnt);</span><br><span class="line">    p-&gt;proposer.bal.cnt &#x3D; ++maxcnt; &#x2F;&#x2F; 找到一个已知的最大的提议号</span><br><span class="line">  &#125;</span><br><span class="line">  msg-&gt;synode &#x3D; msgno; &#x2F;&#x2F; 设置本次propose message的消息号为当前pax machine的消息号</span><br><span class="line">  msg-&gt;proposal &#x3D; p-&gt;proposer.bal; &#x2F;&#x2F; 提议号</span><br><span class="line">  msg-&gt;msg_type &#x3D; msg_type; </span><br><span class="line">  msg-&gt;force_delivery &#x3D; p-&gt;force_delivery;</span><br><span class="line">  </span><br><span class="line">  assert(p-&gt;proposer.msg);</span><br><span class="line">  send_to_acceptors(p, &quot;prepare_msg&quot;)&#123;</span><br><span class="line">      ....</span><br><span class="line">      &#x2F;&#x2F; 向当前视图中的所有节点发送prepare消息</span><br><span class="line">      for (i &#x3D; 0; i &lt; max; i++) &#123;</span><br><span class="line">      if (test_func(s, i)) &#123; &#x2F;&#x2F; 调用all函数，总是return 1</span><br><span class="line">        retval &#x3D; _send_server_msg(s, i, p)&#123;</span><br><span class="line">            msg_link *link &#x3D; msg_link_new(p, to);</span><br><span class="line">            &#x2F;&#x2F; 最终消息被放入像server发送的outgoing消息队列中</span><br><span class="line">            channel_put(&amp;s-&gt;outgoing, &amp;link-&gt;l);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当另外的节点收到prepare请求时，首先通过这个请求的类型字段prepare_op在dispatch_op中进行对应的处理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 处理prepare 请求</span><br><span class="line">pax_msg *reply &#x3D; handle_simple_prepare(p, pm, pm-&gt;synode);</span><br><span class="line">&#x2F;&#x2F; 响应prepare请求，通过reply</span><br><span class="line">if (reply !&#x3D; NULL) SEND_REPLY;</span><br></pre></td></tr></table></figure>
<p>根据paxos协议，当节点收到其他节点发送的prepare消息时，首先判断接受的消息的提议号如果不小于当前的提议号，则响应本节点已经接受的最大提议号的消息值。并做出以后不再接受比接受的prepare提议号小的承诺。在xcom中，处理prepare消息的详过程如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pax_msg *handle_simple_prepare(pax_machine *p, pax_msg *pm, synode_no synode) &#123;</span><br><span class="line">  pax_msg *reply &#x3D; NULL;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 如果本节点已经学到了一个值</span><br><span class="line">  if (finished(p)) &#123; </span><br><span class="line">    reply &#x3D; create_learn_msg_for_ignorant_node(p, pm, synode); &#x2F;&#x2F; 响应已经学到的值</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    int greater &#x3D;</span><br><span class="line">        gt_ballot(pm-&gt;proposal,</span><br><span class="line">                  p-&gt;acceptor.promise); &#x2F;&#x2F; 判断收的提议号本节点做出承诺的提议号</span><br><span class="line">    if (greater || noop_match(p, pm)) &#123; &#x2F;&#x2F; 如果满足承诺条件或者消息类型为noop，noop消息可以直接忽略</span><br><span class="line">      p-&gt;last_modified &#x3D; task_now();</span><br><span class="line">      if (greater) &#123;</span><br><span class="line">        p-&gt;acceptor.promise &#x3D; pm-&gt;proposal; &#x2F;&#x2F; 承诺不再接受更小的提议</span><br><span class="line">      &#125;</span><br><span class="line">      reply &#x3D; create_ack_prepare_msg(p, pm, synode);&#x2F;&#x2F; 创建响应prepare的消息</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return reply;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中判断ballot大小的函数为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int gt_ballot(ballot x, ballot y) &#123;</span><br><span class="line">  return x.cnt &gt; y.cnt || (x.cnt &#x3D;&#x3D; y.cnt &amp;&amp; x.node &gt; y.node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出通过比较cnt和节点的node号来确定</p>
<p>根绝paxos协议，对于响应prepare的消息 reply，会带有本节点已经accept的消息值，如果还没accept，则直接响应空消息ack_prepare_empty_op。响应prepare请求的消息通过以下方式创建：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">reply &#x3D; create_ack_prepare_msg(p, pm, synode);</span><br><span class="line">static pax_msg *create_ack_prepare_msg(pax_machine *p, pax_msg *pm,</span><br><span class="line">                                       synode_no synode) &#123;</span><br><span class="line">  CREATE_REPLY(pm);</span><br><span class="line">  reply-&gt;synode &#x3D; synode;</span><br><span class="line">  if (accepted(p)) &#123; &#x2F;&#x2F; 如果已经接受一个值，那么回复消息中带有这个提议</span><br><span class="line">    reply-&gt;proposal &#x3D; p-&gt;acceptor.msg-&gt;proposal;</span><br><span class="line">    reply-&gt;msg_type &#x3D; p-&gt;acceptor.msg-&gt;msg_type;</span><br><span class="line">    reply-&gt;op &#x3D; ack_prepare_op; &#x2F;&#x2F; 把消息类型设置为ack_prepare_op</span><br><span class="line">    safe_app_data_copy(&amp;reply, p-&gt;acceptor.msg-&gt;a);</span><br><span class="line">  &#125; else &#123; &#x2F;&#x2F; 还没有接受任何值，直接返回空</span><br><span class="line">    reply-&gt;op &#x3D; ack_prepare_empty_op;</span><br><span class="line">  &#125;</span><br><span class="line">  return reply;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当发起prepare的节点收到其他节点对于prepare请求的ack_prepare_op响应时，如果响应的提议号比本节点的提议号大，则进行响应消息的替换，并检测是否可以进入propose过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">static void handle_ack_prepare(site_def const *site, pax_machine *p,</span><br><span class="line">                               pax_msg *m) &#123;</span><br><span class="line"></span><br><span class="line">    bool_t can_propose &#x3D; FALSE;</span><br><span class="line">    if (m-&gt;op &#x3D;&#x3D; ack_prepare_op &amp;&amp;</span><br><span class="line">        gt_ballot(m-&gt;proposal, p-&gt;proposer.msg-&gt;proposal)) &#123; &#x2F;&#x2F; 如果响应的prepare请求是ack_prepare_op(代表非空)并且提议号比自身提议号大</span><br><span class="line">      replace_pax_msg(&amp;p-&gt;proposer.msg, m); &#x2F;&#x2F; 需要将自身的提议内容设置为响应的提议内容</span><br><span class="line">      assert(p-&gt;proposer.msg);</span><br><span class="line">    &#125;</span><br><span class="line">    if (gt_ballot(m-&gt;reply_to, p-&gt;proposer.sent_prop)) &#123; &#x2F;&#x2F; 如果比自身已经收到的所有响应的提议号都大，才进行check_propose过程</span><br><span class="line">      can_propose &#x3D; check_propose(site, p);</span><br><span class="line">    &#125;</span><br><span class="line">    return can_propose;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果收到的ack_prepare_op的个数大于集群中节点数目的一大半，则可以进入propose过程，通过以下方式检测是否prepare成功：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">bool_t check_propose(site_def const *site, pax_machine *p) &#123;</span><br><span class="line"> </span><br><span class="line">  &#123;</span><br><span class="line">    bool_t can_propose &#x3D; FALSE;</span><br><span class="line">    &#x2F;&#x2F; 判断是否大多数节点都已经回复本次prepare</span><br><span class="line">    if (prep_majority(site, p)) &#123;</span><br><span class="line">      &#x2F;&#x2F; 进行一些propose阶段的初始化工作</span><br><span class="line">      p-&gt;proposer.msg-&gt;proposal &#x3D; p-&gt;proposer.bal;</span><br><span class="line">      BIT_ZERO(p-&gt;proposer.prop_nodeset); &#x2F;&#x2F; 清空记录收到节点响应的集合</span><br><span class="line">      p-&gt;proposer.msg-&gt;synode &#x3D; p-&gt;synode; &#x2F;&#x2F; 更新消息号</span><br><span class="line">      init_propose_msg(p-&gt;proposer.msg); &#x2F;&#x2F; 将消息初始化为accept_op</span><br><span class="line">      p-&gt;proposer.sent_prop &#x3D; p-&gt;proposer.bal; &#x2F;&#x2F; 更新收到所有响应里最大的提议号</span><br><span class="line">      can_propose &#x3D; TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">    return can_propose;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>propose:</strong></p>
<p>按照与prepare相同的过程，进入propose阶段后会向所有的节点发送propose请求。当其他节点收到其他节点的accept_op消息时，根据paxos协议，如果propose消息的提议号大于等于当前节点做出的承诺号，则接受这个消息。过程如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">static void handle_accept(site_def const *site, pax_machine *p,</span><br><span class="line">                          linkage *reply_queue, pax_msg *m) &#123;</span><br><span class="line">  &#123;</span><br><span class="line">    pax_msg *reply &#x3D; handle_simple_accept(p, m, m-&gt;synode)&#123;</span><br><span class="line">        pax_msg *reply &#x3D; NULL;</span><br><span class="line">        if (finished(p)) &#123; &#x2F;&#x2F; 已经learned到了一个值</span><br><span class="line">            reply &#x3D; create_learn_msg_for_ignorant_node(p, m, synode);</span><br><span class="line">            &#125; else if (!gt_ballot(p-&gt;acceptor.promise,</span><br><span class="line">                        m-&gt;proposal) || </span><br><span class="line">             noop_match(p, m)) &#123; &#x2F;&#x2F; 如果propose的提议号大于等于本节点承诺不再接受的提议号 或者 pax_msg是noop，或者本节点pax_machine对象的状态是已经accept了一个noop消息</span><br><span class="line">            p-&gt;last_modified &#x3D; task_now();</span><br><span class="line">            replace_pax_msg(&amp;p-&gt;acceptor.msg, m);</span><br><span class="line">            reply-&gt;op &#x3D; ack_accept_op; &#x2F;&#x2F; 设置消息类型为ack_accept_op;</span><br><span class="line">            reply-&gt;synode &#x3D; synode; &#x2F;&#x2F; 设置消息号</span><br><span class="line">        &#125;</span><br><span class="line">        return reply;</span><br><span class="line">    &#125;;</span><br><span class="line">    &#x2F;&#x2F; 响应propose请求</span><br><span class="line">    if (reply !&#x3D; NULL) SEND_REPLY;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当发出accept_op的节点收到ack_accpt_op的消息时，会检查能否进入learn阶段。做以下的处理：                                                             </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">static void handle_ack_accept(site_def const *site, pax_machine *p,</span><br><span class="line">                              pax_msg *m) &#123;</span><br><span class="line">                              </span><br><span class="line">    pax_msg *learn_msg &#x3D; handle_simple_ack_accept(site, p, m)&#123;</span><br><span class="line">        pax_msg *learn_msg &#x3D; NULL;</span><br><span class="line">        if (get_nodeno(site) !&#x3D; VOID_NODE_NO &amp;&amp; m-&gt;from !&#x3D; VOID_NODE_NO &amp;&amp;</span><br><span class="line">            eq_ballot(p-&gt;proposer.bal, m-&gt;reply_to)) &#123; &#x2F;&#x2F; 如果是发送本节点的ack_accept_op消息</span><br><span class="line">            BIT_SET(m-&gt;from, p-&gt;proposer.prop_nodeset);</span><br><span class="line">            if (gt_ballot(m-&gt;proposal, p-&gt;proposer.sent_learn)) &#123; &#x2F;&#x2F; 同ack_prepare_op操作，同样为了拒绝比当前已经接受的accept消息号小的请求</span><br><span class="line">                learn_msg &#x3D; check_learn(site, p);  &#x2F;&#x2F; 检查是否可以进入learn阶段</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return learn_msg;</span><br><span class="line">    &#125;;</span><br><span class="line">    if (learn_msg !&#x3D; NULL) &#123;  &#x2F;&#x2F; 如果learn_msgx消息不为空</span><br><span class="line">      if (learn_msg-&gt;op &#x3D;&#x3D; tiny_learn_op) &#123; &#x2F;&#x2F; 如果设置的learn 消息的方式为tiny_learn_msg，</span><br><span class="line">        send_tiny_learn_msg(site, learn_msg);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        &#x2F;* purecov: begin deadcode *&#x2F;</span><br><span class="line">        assert(learn_msg-&gt;op &#x3D;&#x3D; learn_op);</span><br><span class="line">        send_learn_msg(site, learn_msg);</span><br><span class="line">        &#x2F;* purecov: end *&#x2F;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>learn：</strong></p>
<p>当接受到一半以上的成功accept的响应时，可以进入learn阶段。需要做以下的检查：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">static pax_msg *check_learn(site_def const *site, pax_machine *p) &#123;</span><br><span class="line">  </span><br><span class="line">pax_msg *learn_msg &#x3D; NULL;</span><br><span class="line">if (get_nodeno(site) !&#x3D; VOID_NODE_NO &amp;&amp; prop_majority(site, p)) &#123;</span><br><span class="line"></span><br><span class="line">  if (no_duplicate_payload) &#123; &#x2F;&#x2F; no_duplicate_payload 被设置为1</span><br><span class="line">    learn_msg &#x3D; create_tiny_learn_msg(p, p-&gt;proposer.msg);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    &#x2F;* purecov: begin deadcode *&#x2F;</span><br><span class="line">    init_learn_msg(p-&gt;proposer.msg);</span><br><span class="line">    learn_msg &#x3D; p-&gt;proposer.msg;</span><br><span class="line">    &#x2F;* purecov: end *&#x2F;</span><br><span class="line">  &#125;</span><br><span class="line">  p-&gt;proposer.sent_learn &#x3D; p-&gt;proposer.bal;</span><br><span class="line">&#125;</span><br><span class="line">return learn_msg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当进入learn阶段以后，根据收到的消息是tiny_learn_op和learn_op，做出对应的不同的处理，在更新本节点pax_machine对象时，tiny_learn_op是将对象的acceptor.msg赋learner.msg，而learn_op时是将从其他节点收到的pax_msg赋予本节点pax_machine对象的acceptor.msg和learner.msg。对于前者，如果当前节点已经accet值并且接收到tiny_learn_op消息对应的learn值等于自身accpet值，则直接进入进入do_learn()过程，此时一条消息走完了整个paxos协议，在所有节点上达成一致；如果上述两个条件都不满足，则需要调用send_learn向其他节点学习需要最终的值，主要过程如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void handle_tiny_learn(site_def const *site, pax_machine *pm, pax_msg *p) &#123;</span><br><span class="line">  if (pm-&gt;acceptor.msg) &#123;</span><br><span class="line">    if (eq_ballot(pm-&gt;acceptor.msg-&gt;proposal, p-&gt;proposal)) &#123; &#x2F;&#x2F; 如果是当前已经接收的提议</span><br><span class="line">      pm-&gt;acceptor.msg-&gt;op &#x3D; learn_op;</span><br><span class="line">      update_max_synode(p); &#x2F;&#x2F; 更新已知的最大消息号</span><br><span class="line">      handle_learn(site, pm, pm-&gt;acceptor.msg);</span><br><span class="line">    &#125; else &#123; &#x2F;&#x2F; 如果接收的learn消息不是本节点已经accept的消息，则向其他节点学习</span><br><span class="line">      send_read(p-&gt;synode);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123; &#x2F;&#x2F; 如果本节点还没有接收值，则向其他节点学习</span><br><span class="line">    send_read(p-&gt;synode);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在handle_learn函数中,主要消息的替换和把消息当前pax_machine设置为被选定，此时，消息在paxos中的整个流程结束。此时还会激活sweeper_task协程进行pax_machine 缓冲区的清理和进行Mencius协议的simple<br>paxos 过程。handle_learn主要过程如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">void handle_learn(site_def const *site, pax_machine *p, pax_msg *m) &#123;</span><br><span class="line">  if (!finished(p)) &#123; &#x2F; 避免重复学习新的值</span><br><span class="line">    activate_sweeper(); &#x2F;&#x2F; </span><br><span class="line">    do_learn(site, p, m)&#123;</span><br><span class="line">        if (m-&gt;a) m-&gt;a-&gt;chosen &#x3D; TRUE; &#x2F;&#x2F; 首先将消息设置为被选定状态</span><br><span class="line">        &#x2F;&#x2F; 在do_learn 中，将自身作为acceptor和learner角色时的值替换为最终被决定的消息m</span><br><span class="line">        replace_pax_msg(&amp;p-&gt;acceptor.msg, m);</span><br><span class="line">        replace_pax_msg(&amp;p-&gt;learner.msg, m);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 处理一些特殊消息</span><br><span class="line">    if (m-&gt;a &amp;&amp; m-&gt;a-&gt;body.c_t &#x3D;&#x3D; unified_boot_type) &#123;</span><br><span class="line">      XCOM_FSM(x_fsm_net_boot, void_arg(m-&gt;a));</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;* See if someone is forcing a new config *&#x2F;</span><br><span class="line">    if (m-&gt;force_delivery &amp;&amp; m-&gt;a) &#123;</span><br><span class="line">      &#x2F;* Immediately install this new config *&#x2F;</span><br><span class="line">      switch (m-&gt;a-&gt;body.c_t) &#123;</span><br><span class="line">        case add_node_type:</span><br><span class="line">          ....</span><br><span class="line">          break;</span><br><span class="line">        &#x2F;* purecov: end *&#x2F;</span><br><span class="line">        case remove_node_type:</span><br><span class="line">          ....</span><br><span class="line">          break;</span><br><span class="line">        &#x2F;* purecov: end *&#x2F;</span><br><span class="line">        case force_config_type:</span><br><span class="line">          .....</span><br><span class="line">          break;</span><br><span class="line">        default:</span><br><span class="line">          break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  task_wakeup(&amp;p-&gt;rv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在handle_tiny_learn中，如果本节点acceptor.msg不存在或者acceptor.msg-&gt;proposal不等于tiny_learn_op消息携带的投票器，则表示没有参与之前的accept流程或者当前accept值不是经过大多数同意的值，这两种情况需要调用send_read处理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">static void send_read(synode_no find) &#123;</span><br><span class="line">  &#x2F;&#x2F; 找到一个属于当前视图的节点</span><br><span class="line">  site_def const *site &#x3D; find_site_def(find);</span><br><span class="line"></span><br><span class="line">  &#x2F;* See if node number matches ours *&#x2F;</span><br><span class="line">  if (site) &#123;</span><br><span class="line">    &#x2F;&#x2F;  如果找到的节点不是本节点</span><br><span class="line">    if (find.node !&#x3D; get_nodeno(site)) &#123;</span><br><span class="line">      pax_msg *pm &#x3D; pax_msg_new(find, site); &#x2F;&#x2F; 创建一个pax_msg消息</span><br><span class="line">      ref_msg(pm); &#x2F;&#x2F; 对本条pm消息引用计数</span><br><span class="line">      create_read(site, pm); &#x2F;&#x2F; 将消息类型设置为read_op类型</span><br><span class="line">      </span><br><span class="line">      &#x2F;&#x2F; 如果本节点还没有分配节点号(why?)</span><br><span class="line">      if (get_nodeno(site) &#x3D;&#x3D; VOID_NODE_NO)</span><br><span class="line">        send_to_others(site, pm, &quot;send_read&quot;); &#x2F;&#x2F; 向所有的其它节点发送read_op消息</span><br><span class="line">      else</span><br><span class="line">        send_to_someone(site, pm, &quot;send_read&quot;); &#x2F;&#x2F; 通过round-bin的方式挑选一个live节点发送read_op</span><br><span class="line"></span><br><span class="line">      unref_msg(&amp;pm); &#x2F;&#x2F; 解引用，如果引用计数为0，析构本条消息</span><br><span class="line">    &#125; else &#123; &#x2F;&#x2F; 如果找到的节点是本节点自身</span><br><span class="line">      pax_msg *pm &#x3D; pax_msg_new(find, site);</span><br><span class="line">      ref_msg(pm);</span><br><span class="line">      create_read(site, pm);</span><br><span class="line">      send_to_others(site, pm, &quot;send_read&quot;);</span><br><span class="line">      unref_msg(&amp;pm);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>提交消息到上层客户端</strong></p>
<p>当一条消息被learn之后，表明已经在大多数节点上达成一致，此时便可以进入paxos协议的提交阶段，在xcom模块中，即将达成一致的消息返回给MGR的GCS模块。提交阶段主要分为两个过程：x_fetch和x_execute，前者是获取之前已经被do_learn()设置为被选定状态的消息，后者用于将这些消息发送给上层GCS模块。主要通过executor_task()协程进行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">static int executor_task(task_arg arg MY_ATTRIBUTE((unused))) &#123;</span><br><span class="line"></span><br><span class="line">  if (executed_msg.msgno &#x3D;&#x3D; 0) executed_msg.msgno &#x3D; 1;</span><br><span class="line">  delivered_msg &#x3D; executed_msg;</span><br><span class="line">  ep-&gt;xc.state &#x3D; x_fetch;</span><br><span class="line">  executor_site &#x3D; find_site_def_rw(executed_msg);</span><br><span class="line"></span><br><span class="line">  while (!xcom_shutdown &amp;&amp; ep-&gt;xc.state !&#x3D; 0) &#123;</span><br><span class="line">    &#x2F;&#x2F; 进入请求获取阶段</span><br><span class="line">    if (ep-&gt;xc.state &#x3D;&#x3D; x_fetch) &#123; </span><br><span class="line">        TASK_CALL(get_xcom_message(&amp;ep-&gt;xc.p, executed_msg, FIND_MAX)); &#x2F;&#x2F; 调用get_xcom_message获取已经被选定但是还未被execute_task感知的消息</span><br><span class="line">        x_fetch(&amp;ep-&gt;xc)&#123;</span><br><span class="line">            if (x_check_exit(xc)) &#123;</span><br><span class="line">                xc-&gt;state &#x3D; x_terminate;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                SET_EXECUTED_MSG(incr_synode(executed_msg)); &#x2F;&#x2F; 增加executed_msg号，用于表示已经走完Paxos全流程但还未被executor_task()处理的最小的synode请求。同时递增全局的下一个可用的current_message,用于proposer_task中客户端消息号的赋值</span><br><span class="line">                if (x_check_execute_inform(xc)) &#123;</span><br><span class="line">                    xc-&gt;state &#x3D; x_execute; &#x2F;&#x2F; 将状态设置为x_execute</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123; &#x2F;&#x2F; 当协程是execute状态，处于请求执行阶段</span><br><span class="line">      ep-&gt;xc.state(&amp;ep-&gt;xc)； &#x2F;&#x2F; 调用x_execute协程</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于 x_execute 协程，在执行之前会首先判断是否满足执行条件，delivery_limit为视图变更阶段退出节点可以执行的消息号的上限，只有当前消息号小于delivery_limit时才可以执行，详见集群成员变更过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">static void x_execute(execute_context *xc) &#123;</span><br><span class="line">  site_def const *x_site &#x3D; find_site_def(delivered_msg);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  xc-&gt;p &#x3D; get_cache(delivered_msg);</span><br><span class="line">  </span><br><span class="line">  if (xc-&gt;p-&gt;learner.msg-&gt;msg_type !&#x3D; no_op) &#123;</span><br><span class="line">    &#x2F;* 只有小于delivery_limit时，才可以执行 *&#x2F;</span><br><span class="line">    if (xc-&gt;exit_flag &#x3D;&#x3D; 0 || synode_lt(delivered_msg, xc-&gt;delivery_limit)) &#123;</span><br><span class="line">     </span><br><span class="line">      last_delivered_msg &#x3D; delivered_msg;</span><br><span class="line">      execute_msg(find_site_def_rw(delivered_msg), xc-&gt;p, xc-&gt;p-&gt;learner.msg);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;* delivered_msg 等于当前配置的start号，表示此配置刚开始执行，旧配置已经结束，可以进行垃圾回收机制 *&#x2F;</span><br><span class="line">  if (synode_eq(delivered_msg, x_site-&gt;start)) &#123;</span><br><span class="line">    garbage_collect_servers();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;* 检测是否可以退出和增加delivered_msg *&#x2F;</span><br><span class="line">  x_check_increment_execute(xc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void execute_msg(site_def *site, pax_machine *pma, pax_msg *p) &#123;</span><br><span class="line">  </span><br><span class="line">  last_delivered_msg &#x3D; delivered_msg;</span><br><span class="line">  execute_msg(find_site_def_rw(delivered_msg), xc-&gt;p, xc-&gt;p-&gt;learner.msg)&#123;</span><br><span class="line">    app_data_ptr a &#x3D; p-&gt;a;</span><br><span class="line">    &#x2F;&#x2F; 对于不同的消息类型，做不同的处理</span><br><span class="line">    switch (a-&gt;body.c_t) &#123;</span><br><span class="line">      &#x2F;&#x2F; 配置消息</span><br><span class="line">      case unified_boot_type:</span><br><span class="line">      case force_config_type:</span><br><span class="line">        deliver_config(a);</span><br><span class="line">      case add_node_type:</span><br><span class="line">      case remove_node_type:</span><br><span class="line">        break;</span><br><span class="line">      case app_type:</span><br><span class="line">        &#x2F;&#x2F; 如果是客户端类型消息，将会把消息发送到客户端，最终会执行MGR上层注册到Xcom的回调处理函数xcom_receive_data进行处理。</span><br><span class="line">        deliver_to_app(pma, a, delivery_ok);</span><br><span class="line">        break;</span><br><span class="line">      &#x2F;&#x2F; 全局视图消息</span><br><span class="line">      case view_msg:</span><br><span class="line">        deliver_global_view_msg(site, p-&gt;synode);</span><br><span class="line">        break;</span><br><span class="line">      default:</span><br><span class="line">        break;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="2-2-1-simple-paxos协议过程"><a href="#2-2-1-simple-paxos协议过程" class="headerlink" title="2.2.1 simple paxos协议过程"></a>2.2.1 simple paxos协议过程</h4><p>在Mencius算法中，所谓simple paxos即在设置leader角色的paxos协议过程中，规定了：</p>
<ul>
<li>只有leader可以正常的提议值，且当leader节点提议no-op值时，不用经过两阶段。</li>
<li>非leader节点只能提议no-op值，且必须经过三阶段</li>
</ul>
<p>对于第一点要求，由于非leader节点只能提议no-op值，因此leader提议no-op时不经过两阶段过程也不会造成不一致的情况；对于第二点要求，虽然非leader节点只可以提议非no-op值，但最后被decide的值也不一定是no-op，因为此时可能leader节点提议的正常事务消息已经被部分节点accept，这里的三阶段可以利用paxos原理，保证不会发生不一致的现象。</p>
<p>何时提议no-op值？</p>
<p>在Mencius算法中，提议no-op的场景如下：</p>
<ul>
<li><ol>
<li>instance序列中，当大于本节点负责的instance已经被选定value时，所有本节点负责的instance且索引小于这个已经被决定的instance都被提议no-op</li>
</ol>
</li>
<li><ol start="2">
<li>非leader节点怀疑leader节点故障，希望提议no-op填充故障leader节点负责的instance<br><img src="https://img-blog.csdnimg.cn/20201030111556671.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI4MjU4OTAz,size_16,color_FFFFFF,t_70#pic_center" alt="image"></li>
</ol>
</li>
</ul>
<p>对于第一点，在xcom模块中，主要通过sweeper_task 协程负责触发提议no-op的过程，首先会寻找本节点上已经执行的消息号executed_msg，然后从此消息号开始检测是否需要提议no-op消息。首先需要判断需要检测的消息号是不是小于距今已知的最大消息号(如果大于，那么代表以后本节点可能会提议此消息号，还不需要进行skip操作)，根据此消息号从paxos cache中新建或者查找一个已经存在的pax machine，即instance，如果此instane满足一下条件:没有处于被占用的状态，没有accept任何值，自身没有提议任何值，没有选定任何值，则可以进行skip操作。</p>
<p>sweeper不停的增加消息号，检测每个消息号对应的instance状态，对于满足条件的进行skip操作。主要过程如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">static int sweeper_task(task_arg arg MY_ATTRIBUTE((unused))) &#123;</span><br><span class="line">  </span><br><span class="line">  ep-&gt;find &#x3D; get_sweep_start(); &#x2F;&#x2F; 初始化为本节点的已经被执行的消息号</span><br><span class="line">  </span><br><span class="line">  while (!xcom_shutdown) &#123; &#x2F;&#x2F; 不停处于检测状态</span><br><span class="line">    ep-&gt;find.group_id &#x3D;</span><br><span class="line">        executed_msg.group_id; &#x2F;* In case group id has changed *&#x2F;</span><br><span class="line">    &#123;</span><br><span class="line">      while (synode_lt(ep-&gt;find, max_synode) &amp;&amp; !too_far(ep-&gt;find)) &#123;</span><br><span class="line">        &#x2F;* pax_machine * pm &#x3D; hash_get(ep-&gt;find); *&#x2F;</span><br><span class="line">        pax_machine *pm &#x3D; 0;</span><br><span class="line">        if (ep-&gt;find.node &#x3D;&#x3D; VOID_NODE_NO) &#123;</span><br><span class="line">          if (synode_gt(executed_msg, ep-&gt;find)) &#123;</span><br><span class="line">            ep-&gt;find &#x3D; get_sweep_start();</span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">        &#125;</span><br><span class="line">        pm &#x3D; get_cache(ep-&gt;find); &#x2F;&#x2F; 寻找或者新建一个对应消息号的instance</span><br><span class="line">        if (pm &amp;&amp; !pm-&gt;force_delivery) &#123; &#x2F;* We want full 3 phase Paxos for</span><br><span class="line">                                            forced messages *&#x2F;</span><br><span class="line">          </span><br><span class="line">          if (!is_busy_machine(pm) &amp;&amp; pm-&gt;acceptor.promise.cnt &#x3D;&#x3D; 0 &amp;&amp;</span><br><span class="line">              !pm-&gt;acceptor.msg &amp;&amp; !finished(pm)) &#123; &#x2F;&#x2F;instance未被使用, 没有在对应instance上做出承诺,没有接受别的节点建议的消息或者自身未建议消息,instance没有学习到任何值</span><br><span class="line">            pm-&gt;op &#x3D; skip_op;</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            skip_msg(pax_msg_new(ep-&gt;find, find_site_def(ep-&gt;find))) &#x2F;&#x2F; 新建一条skip 消息进行 skip操作&#123;</span><br><span class="line">                prepare(p, skip_op);</span><br><span class="line">                p-&gt;msg_type &#x3D; no_op;</span><br><span class="line">                return send_to_all(p, &quot;skip_msg&quot;); &#x2F;&#x2F; 根据Mencius算法，对于skip消息协调者可以直接入learn阶段，而不用三阶段或者两阶段</span><br><span class="line">            &#125;;</span><br><span class="line">            printf(&quot;can skipping, %lld,   %lld\n&quot;,(long long)ep-&gt;find.msgno, (long long)ep-&gt;find.node);</span><br><span class="line">            fflush(stdout);</span><br><span class="line">           </span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ep-&gt;find &#x3D; incr_msgno(ep-&gt;find); &#x2F;&#x2F; 递增检测所有的消息号</span><br><span class="line">        printf(&quot;next to detect skip, %lld,  %lld\n&quot;,(long long)ep-&gt;find.msgno, (long long)ep-&gt;find.node);</span><br><span class="line">        fflush(stdout);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于第二点，发生在节点提交到上层MGR时，在basic paxos中的executor_task协程中，在x_fetch，也即获取可以提交给上层MGR的消息时，如果对于一个消息号对应的instance在本节点上还未被决定，首先本节点将会尝试从其他节点learn对应的消息，如果尝试无果，将会通过三阶段(从prepare过程开始)尝试skip这条消息。对应代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int get_xcom_message(pax_machine **p, synode_no msgno, int n) &#123;</span><br><span class="line"> </span><br><span class="line">  ....</span><br><span class="line">  *p &#x3D; force_get_cache(msgno); &#x2F;&#x2F; 获取消息号对应的paxs machine,即instance</span><br><span class="line"> </span><br><span class="line">  dump_debug_exec_state();</span><br><span class="line">  while (!finished(*p)) &#123; &#x2F;&#x2F; 如果此instance还未达成一致，不停重试</span><br><span class="line">    ....</span><br><span class="line">    find_value(ep-&gt;site, &amp;ep-&gt;wait, n); &#x2F;&#x2F; 从其他节点学习或者尝试skip这条instance</span><br><span class="line">    *p &#x3D; get_cache(msgno);</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 find_value中，当前的节点会在4次以内获取指定msgno消息的尝试。第一次和第二次会尝试从其他节点learn对应的消息。而从第3次开始，本节点将通过检测集群中还活动的节点，如果本节点可以成为leader，会通过三阶段尝试跳过这条消息，否则还是从其他节点读取。如果前三次尝试仍然失败，从第4次开始，集群中所有节点都会进行三阶段过程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">static void find_value(site_def const *site, unsigned int *wait, int n) &#123;</span><br><span class="line"></span><br><span class="line">  switch (*wait) &#123;</span><br><span class="line">    case 0: </span><br><span class="line">    case 1: &#x2F;&#x2F; 第一次和第二次都会尝试从其他节点读取</span><br><span class="line">      read_missing_values(n);</span><br><span class="line">      (*wait)++;</span><br><span class="line">      break;</span><br><span class="line">    case 2: &#x2F;&#x2F; 第三次：如果本节点是集群中节点号最小的节点，则由本节点负责提议no op，接下来进入push_msg_3p过程</span><br><span class="line">      if (iamthegreatest(site))</span><br><span class="line">        propose_missing_values(n);</span><br><span class="line">      else</span><br><span class="line">        read_missing_values(n);</span><br><span class="line">      (*wait)++;</span><br><span class="line">      break;</span><br><span class="line">    case 3:</span><br><span class="line">      propose_missing_values(n);</span><br><span class="line">      break;</span><br><span class="line">    default:</span><br><span class="line">      break;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-故障检测"><a href="#2-2-故障检测" class="headerlink" title="2.2 故障检测"></a>2.2 故障检测</h3><p>MGR中故障响应机制主要包括故障探测，移除故障节点和自动重新加入，其中xcom模块主要负责故障探测。每个节点都有一个server对象，其中与故障检测相关的字段如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Server definition *&#x2F;</span><br><span class="line">struct server &#123;</span><br><span class="line">    ...</span><br><span class="line">  double detected;           &#x2F;* Last incoming *&#x2F;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct site_def &#123;</span><br><span class="line">  ....</span><br><span class="line">  detector_state detected;   &#x2F;* 每个节点的最后一条传入消息的时间 *&#x2F;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">typedef double detector_state[NSERVERS];</span><br></pre></td></tr></table></figure>

<p>xcom在每次成功的发送数据到某节点或者从某个节点接收到数据时都会记录当前时间(detected time，即server字段的detected)。意味着这个节点在当前时间还活着。</p>
<p>与故障检测相关的协程主要为alive_task()和detector_task()，</p>
<p>alive_task负责：</p>
<ul>
<li><p>在节点空闲了0.5秒后，alive_task()会发送i_am_alive_op消息给其他节点。空闲是指0.5秒内没有发送任何消息出去。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (server_active(site, get_nodeno(site)) &lt; sec - 0.5)</span><br></pre></td></tr></table></figure>
</li>
<li><p>当某个节点4秒(#define MAX_SILENT 4)内没有任何通信时(代码中称作may_be_dead)，发送are_you_alive_op消息给这个节点，去探查该节点是否还活着。</p>
</li>
</ul>
<p>detector_task()主要任务是：</p>
<p>每1秒做一轮检查。检查节点是否还活着。判断的标准是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define DETECTOR_LIVE_TIMEOUT 5.0</span><br><span class="line"></span><br><span class="line">detected_time &gt; task_now() - DETECTOR_LIVE_TIMEOUT</span><br></pre></td></tr></table></figure>

<p>即5秒内没有和这个节点通信。如果此节点的detected time在5秒之内，则为活着，否则认为该节点可能已经死去。</p>
<p>当detector_task()发现任何节点的状态发生了变化：从活着变成可能死了；从可能死了变成活着</p>
<p>都会通过local view回调函数xcom_receive_local_view来处理状态变化。状态的变化由GCS模块处理。</p>
<h3 id="2-3-集群成员变更"><a href="#2-3-集群成员变更" class="headerlink" title="2.3 集群成员变更"></a>2.3 集群成员变更</h3><p>xcom集群成员变更算法参考了两篇论文，一篇是lamport论文 Reconfiguring a State Machine 中的方法。论文解读如下：</p>
<p>文档：paper Reconfiguring a State Machine</p>
<p>链接：<a href="http://note.youdao.com/noteshare?id=fe63ab4a6e146e67927cca351bc2e806&amp;sub=56A28ECB00134D44A989A080C9E0984E" target="_blank" rel="noopener">http://note.youdao.com/noteshare?id=fe63ab4a6e146e67927cca351bc2e806&amp;sub=56A28ECB00134D44A989A080C9E0984E</a></p>
<p>另一篇是：</p>
<p>The SMART way to migrate replicated stateful services. In Proc. EuroSys’06, ACM SIGOPS/EuroSys European Conference on Computer Systems </p>
<p>集群成员变更分为加入节点和删除节点的过程，一致性协议中集群成员变更的方法主要分为两类，一类是两阶段方式，一类是raft 论文中提到的joint consencus方式。在xcom中采用了上述论文中的Ra算法，其中a为alpha个延迟，即集群成员变更的消息被提议以后会经过alpha延迟后才生效，这可以允许alpha个消息的并发提交。经过alpah个消息后，每个节点按照新的配置进行集群成员变更的操作。在xcom中，alpha对应的变量为<strong>event_horizon</strong>。</p>
<p>当有新的节点加入集群时，不会发生数据丢失的问题。但是当有节点退出时，处理过程比较复杂。下面通过一个例子介绍一下具体的节点退出过程：</p>
<p>  考虑三个配置C1和C2，C3。C1有两个节点，A和B。C2只有节点B。C3为空。<br>  消息编号为N的配置将在（至少）alpha消息延迟后激活，其中alpha 是event horizon大小。</p>
<p>  所以，C1.start=C1+alpha，C2.start=C2+alpha。<br>  从C1中删除的A在新的配置C2（在本例中为B）中的大多数节点从配置C1中学习了所有消息(所有小于C2.start的消息)之前，不能退出。<br>  如何知道大部分C2已经学习到了这些信息？</p>
<p>  假设E表示尚未由被选定（并执行）的第一条消息，则提议者将不会尝试提出编号大于等于E+alpha的消息，<br>  并且所有消息编号大于等于E+alpha的传入消息都将被忽略。<br>  E由executor_task递增，因此所有小于E的消息都是已知的。这意味着当E+alpha的值可以被学习到时，直到E（包括E）的所有消息也都已经被学习到，<br>  尽管并非所有消息E+1..E+alpha-1都需要被learn。</p>
<p>  <strong>这就要求退出的节点（A）需要等待，直到它知道C2.start+alpha的值，<br>  因为到那时它知道C2中的大多数节点已经准备好执行C2.start，<br>  这反过来意味着C2中的大多数节点都知道来自配置C1的所有值。</strong><br>  注意，离开C1的节点应该传递给应用程序的最后一条消息是C2.start-1，这是C1的最后一条消息。</p>
<p>  退出的节点如何从下一个配置中获取被选定的值？有两种方法都被使用。<br>  首先，尝试退出的节点可以简单地请求消息。get_xcom_message（）将对所有消息小于等于max_synode执行此操作，但可能需要一些时间。<br>  其次，C2的节点可以将消息C2.start..C2.start+alpha发送给被移除的节点（C1中的节点，而不是C2中的节点）。<br>  inform_removed()函数负责执行此操作。通过跟踪包含要退出的节点的最旧配置来处理配置足够接近C0&lt;C1&lt;=C0+alpha的情况。</p>
<p>  上述方式将处理离开C1的节点的情况。如果处理离开C2的节点呢？C3为空，因此离开C2的B不能等待来自C3的消息。<br>  但由于C3是空的，所以不需要等待。它可以在执行完C3.start‐1（C2的最后一条消息）后立即退出。<br>  如果C3.start-1&lt;C2.start+alpha呢？如果C2和C3接近，就会发生这种情况：<br>  B将在A有机会学习C2.start+alpha之前退出，这将使A永远都被hang住。<br>  显然，需要施加一个额外的约束，即C3.start必须大于C2.start+alpha。这由空配置的特殊测试来处理。</p>
<p>  除了上述方法之外，还有中比较完美的解决方案尚未被实现即raft论文中的共同一致，因为它需要对一致性协议的过程进行更多的修改。<br>  按照共同一致算法，在xcom中，如果我们要求消息C2..C2.start‐1的大部分来自C1中的节点和C2中的节点，<br>  那么不在C2中的节点可以在执行消息C2.start-1后退出，因为我们知道C2的大多数节点也同意这些消息，<br>  因此它们不再依赖于不在C2中的节点。即使C2是空的，这也是有效的。<br>  请注意，要求C1和C2的多数与要求C1+C2的多数不同，这意味着提议者逻辑需要考虑来自两组不同接受者的应答者。</p>
<p>当集群成员变更的配置消息传来时，首先会进行配置的更改，如果配置更改成功，会判断本节点是属于删除的节点还是新添加的节点还是旧配置中存在，新配置中还会继续保留的节点，其中后两种情况的处理过程相同；下面看一下节点加入或者退出时具体的执行过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">static void x_fetch(execute_context *xc) &#123;</span><br><span class="line">  &#x2F;* 在准备好执行来自新配置定义的消息之前，不要传递消息。此时需要保证大多数节点已经从旧配置集群中学习到了所有消息。 *&#x2F;</span><br><span class="line"></span><br><span class="line">  app_data *app &#x3D; xc-&gt;p-&gt;learner.msg-&gt;a;</span><br><span class="line">  if (app &amp;&amp; is_config(app-&gt;body.c_t) &amp;&amp;</span><br><span class="line">      synode_gt(executed_msg, get_site_def()-&gt;boot_key)) &#x2F;* 判断是否是配置变更请求，当节点退出时，消息类型为remove_node_type *&#x2F;</span><br><span class="line">  &#123;</span><br><span class="line">    site_def *site &#x3D; 0;</span><br><span class="line">    bool_t reconfiguration_successful &#x3D;</span><br><span class="line">        handle_config(app, (xc-&gt;p-&gt;learner.msg-&gt;force_delivery !&#x3D; 0));</span><br><span class="line">    if (reconfiguration_successful) &#123;</span><br><span class="line">      &#x2F;*如果重新配置失败，则不会产生任何影响。只有当重新配置生效时，下面的过程才有意义 *&#x2F;</span><br><span class="line">      set_last_received_config(executed_msg);</span><br><span class="line">      garbage_collect_site_defs(delivered_msg);</span><br><span class="line">      site &#x3D; get_site_def_rw();</span><br><span class="line">      if (site &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        xc-&gt;state &#x3D; x_terminate;</span><br><span class="line">        return;</span><br><span class="line">      &#125;</span><br><span class="line">     </span><br><span class="line">      if (xc-&gt;exit_flag &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        &#x2F;* We have not yet set the exit trigger *&#x2F;</span><br><span class="line">        setup_exit_handling(xc, site); &#x2F;&#x2F; 设置退出逻辑，包括设置退出的延迟消息号等</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">  &#x2F;* 检查是否可以退出和增加 executed_msg *&#x2F;</span><br><span class="line">  x_check_increment_fetch(xc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于setup_exit_handling 函数，主要过程如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">static void setup_exit_handling(execute_context *xc, site_def *site) &#123;</span><br><span class="line">  synode_no delay_until;</span><br><span class="line">  if (is_member(site)) &#123; &#x2F;&#x2F; 如果本节点属于新的配置，那么代表本节点不是新添加进来的节点，也不是被删除的节点，可能是新被加入的节点，也可能是已经存在的节点</span><br><span class="line">    delay_until &#x3D; compute_delay(site-&gt;start, site-&gt;event_horizon); &#x2F;&#x2F; 根据event_horizon 计算退出的延迟，计算方式为start.msgno +&#x3D; event_horizon</span><br><span class="line">  &#125; else &#123; </span><br><span class="line">    &#x2F;* 看看本节点离开时下一个配置是否会是空，即上述例子中的C3配置。如果新的site为空，应该在从配置传递完最后一条消息后退出。 *&#x2F;</span><br><span class="line"></span><br><span class="line">    &#x2F;* 在下一个配置开始生效后不能传递任何消息 *&#x2F;</span><br><span class="line">    xc-&gt;delivery_limit &#x3D; site-&gt;start;</span><br><span class="line"></span><br><span class="line">    &#x2F;* </span><br><span class="line">    如果本节点不是新配置的成员，应该在看到超过当前节点结束消息号的足够多的消息后退出，对应于上述例子中的c2+start。这样可以确保下一个配置的大多数节点都学习到了属于当前配置的所有消息。</span><br><span class="line">     *&#x2F;</span><br><span class="line">    xc-&gt;exit_synode &#x3D; compute_delay(site-&gt;start, site-&gt;event_horizon);</span><br><span class="line">    if (is_empty_site(site)) &#123;</span><br><span class="line">      &#x2F;* 如果新配置为空，增加start以允许节点在start之前终止。这就好像在exit_synode之后有一个非空的组，有效地允许当前组的大多数成员在exit_synode之前的所有消息上达成一致。</span><br><span class="line">       *&#x2F;</span><br><span class="line">      site-&gt;start &#x3D; compute_delay(</span><br><span class="line">          compute_delay(site-&gt;start, site-&gt;event_horizon), site-&gt;event_horizon);</span><br><span class="line">    &#125;</span><br><span class="line">    if (!synode_lt(xc-&gt;exit_synode, max_synode)) &#123;</span><br><span class="line">      &#x2F;* 需要来自下一个配置的消息，所以相应地设置max_synode。 *&#x2F;</span><br><span class="line">      set_max_synode(incr_synode(xc-&gt;exit_synode));</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;* 设置在哪里切换到执行并通知删除的节点 *&#x2F;</span><br><span class="line">    delay_until &#x3D; xc-&gt;exit_synode;</span><br><span class="line"></span><br><span class="line">    &#x2F;* 代表本节点是被删除的节点且将要退出 *&#x2F;</span><br><span class="line">    xc-&gt;exit_flag &#x3D; 1;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  if (synode_gt(delay_until, max_synode))</span><br><span class="line">    set_max_synode(incr_msgno(delay_until)); &#x2F;&#x2F; 更新m最大消息号</span><br><span class="line">  fifo_insert(delay_until);</span><br><span class="line">  (xc-&gt;inform_index)++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面检测此时是否可以退出:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">static void x_check_increment_fetch(execute_context *xc) &#123;</span><br><span class="line">  if (x_check_exit(xc)) &#123; &#x2F;&#x2F; 表明本节点需要退出</span><br><span class="line">    xc-&gt;state &#x3D; x_terminate;</span><br><span class="line">  &#125; else &#123; &#x2F;&#x2F; 本节点还属于新的配置中，不需要退出</span><br><span class="line">    SET_EXECUTED_MSG(incr_synode(executed_msg));</span><br><span class="line">    if (x_check_execute_inform(xc)) &#123; &#x2F;&#x2F; inform_removed 函数，将消息推送到将要离开的节点</span><br><span class="line">      xc-&gt;state &#x3D; x_execute; 然后便可以继续执行</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 当本节点是被删除的节点且满足删除条件时，可以退出；满足删除的条件为本节点delivered_msg消息号没有超过传递限制且本节点executed_msg消息号已经等于exit_synode消息号了，那么此时也可以保证新配置中节点已经学习到了旧配置中所有的消息</span><br><span class="line">static int x_check_exit(execute_context *xc) &#123;</span><br><span class="line">  return (xc-&gt;exit_flag &amp;&amp; !synode_lt(executed_msg, xc-&gt;exit_synode) &amp;&amp;</span><br><span class="line">          !synode_lt(delivered_msg, xc-&gt;delivery_limit));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-协程模块task"><a href="#3-协程模块task" class="headerlink" title="3. 协程模块task"></a>3. 协程模块task</h2><p>xcom首先实现了一套协程库：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;** \file</span><br><span class="line">        Rudimentary task system in portable C, based on Tom Duff&#39;s switch-based</span><br><span class="line">   coroutine trick</span><br><span class="line">        and a stack of environment structs. (continuations?)</span><br><span class="line">        Nonblocking IO and event handling need to be rewritten for each new OS.</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure>
<p>可以看出xcom中采用了<a href="https://www.chiark.greenend.org.uk/~sgtatham/coroutines.html" target="_blank" rel="noopener">基于”Duff-switch”的协程实现</a>，所谓”Duff-switch”,是指主要通过c语言中的switch语句与 循环语句的嵌套实现函数退出后循环语句的继续执行，下面展示一种协程的无堆栈实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int function(void) &#123;</span><br><span class="line">    static int i, state &#x3D; 0;</span><br><span class="line">    switch (state) &#123;</span><br><span class="line">        case 0: </span><br><span class="line">        for (i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">            state &#x3D; 1; </span><br><span class="line">            return i;</span><br><span class="line">            case 1:;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数的作用是第i次调用时返回i，最多10次，其核心部分为switch语句以及return前后两句，通过设置不同的state来保证下一次调用时从上次退出的地方继续执行。</p>
<p>因此在每次调用return时设置的不同的state，利用switch的条件跳转可以跳转到函数指定的位置继续执行。可以利用<strong>LINE</strong>宏来设置state，下面是简单利用<strong>LINE</strong> 实现协程举例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">#define TASK_BEGIN static int state &#x3D; 0; switch (state) &#123; case 0:</span><br><span class="line">#define TASK_YIELD(x) do &#123; state &#x3D; __LINE__; return x; case __LINE__:; &#125; while (0)</span><br><span class="line">#define TASK_END &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void f1() &#123;</span><br><span class="line">    TASK_BEGIN;</span><br><span class="line">    puts(&quot;1&quot;);</span><br><span class="line">    puts(&quot;2&quot;);</span><br><span class="line">    TASK_YIELD();</span><br><span class="line">    puts(&quot;3&quot;);</span><br><span class="line">    TASK_END;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void f2() &#123;</span><br><span class="line">    TASK_BEGIN;</span><br><span class="line">    puts(&quot;x&quot;);</span><br><span class="line">    TASK_YIELD();</span><br><span class="line">    puts(&quot;y&quot;);</span><br><span class="line">    puts(&quot;z&quot;);</span><br><span class="line">    TASK_END;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main (void) &#123;</span><br><span class="line">    f1();</span><br><span class="line">    f2();</span><br><span class="line">    f1();</span><br><span class="line">    f2();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void f1()&#123;</span><br><span class="line">    static int state &#x3D; 0;</span><br><span class="line">    switch (state)</span><br><span class="line">    &#123; case 0:</span><br><span class="line">        puts(&quot;1&quot;);</span><br><span class="line">        puts(&quot;2&quot;);</span><br><span class="line">        do&#123; </span><br><span class="line">            state &#x3D; __LINE__;</span><br><span class="line">            return;</span><br><span class="line">    case __LINE__:;</span><br><span class="line">            &#125; while (0);</span><br><span class="line">        puts(&quot;3&quot;);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码运行后会依次输出1,2,x,3,y,z。可以看出各个函数执行是一个交互的过程，并能保证函数退出后继续从上次返回的位置执行。<br>main()中演示的过程便是协程切换的过程。</p>
<p>因为switch内部不能任意定义变量，所以需要在TASK_BEGIN之前定义所需变量，在xcom模块中，每个协程开始之前都会定义和初始化与协程运行和切换相关的上下文。xcom中协程机制的实现和如上的实现方式相同，但是添加了堆栈，更为复杂。xcom中所有的协程(task)也通过类似于TASK_BEGIN, TASK_YEILD, TASK_END以及其他更为完善的机制进行协程的开始，睡眠，抢占和跳转。下面将主要介绍xcom的协程机制：</p>
<p>协程的数据结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">struct task_env &#123;</span><br><span class="line">  linkage l;    &#x2F;* Used for runnable tasks and wait queues *&#x2F;</span><br><span class="line">  linkage all;  &#x2F;* Links all tasks *&#x2F;</span><br><span class="line">  int heap_pos; &#x2F;* Index in time priority queue, necessary for efficient removal</span><br><span class="line">                 *&#x2F;</span><br><span class="line">  terminate_enum</span><br><span class="line">      terminate;        &#x2F;* Set this and activate task to make it terminate *&#x2F;</span><br><span class="line">  int refcnt;           &#x2F;* Number of references to task *&#x2F;</span><br><span class="line">  int taskret;          &#x2F;* Return value from task function *&#x2F;</span><br><span class="line">  task_func func;       &#x2F;* The task function *&#x2F;</span><br><span class="line">  task_arg arg;         &#x2F;* Argument passed to the task *&#x2F;</span><br><span class="line">  const char *name;     &#x2F;* The task name *&#x2F;</span><br><span class="line">  TaskAlign *where;     &#x2F;* High water mark in heap *&#x2F;</span><br><span class="line">  TaskAlign *stack_top; &#x2F;* The stack top *&#x2F;</span><br><span class="line">  TaskAlign *sp;        &#x2F;* The current stack pointer *&#x2F;</span><br><span class="line">  double time;          &#x2F;* Time when the task should be activated *&#x2F;</span><br><span class="line">  TaskAlign buf[TASK_POOL_ELEMS]; &#x2F;* Heap and stack *&#x2F;</span><br><span class="line">  int debug;</span><br><span class="line">  int waitfd;</span><br><span class="line">  int interrupt; &#x2F;* Set if timeout while waiting *&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>前两个个字段用于所有协程底层数据结构的阻止方式；refcnt用于表示一个协程被引用的次数，协程只被创建一次，但是可以被引用多次，当引用次数为0时，便可以删除；func字段是一个函数指针，指向协程代表的函数，taskret表示协程的返回值，用于判断协程被挂起还是真的退出，name表示协程代表的函数的名；缓冲区buf用于协程的堆栈，where代表堆的最高水位，初始指向buf[0]的位置，stack_top字段指向栈顶，初始指向buf[TASK_POOL_ELEMS -1 ]位置，每分配一次协程栈便减一，sp用于表示某个协程在栈中的位置。</p>
<p>另外比较重要的数据结构包括task queue：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Priority queue of task_env *&#x2F;</span><br><span class="line">struct task_queue &#123;</span><br><span class="line">  int curn;</span><br><span class="line">  task_env *x[MAXTASKS + 1];</span><br><span class="line">&#125;;</span><br><span class="line">typedef struct task_queue task_queue;</span><br></pre></td></tr></table></figure>
<p>task_queue 定义的全局变量为task_time_q，用来保存休眠的协程，处于task_time_q的协程不能立刻执行，需要等待一段时间。</p>
<p>此外由全局活动(等待执行)协程列表tasks，是协程创建(task_new())后构成的双向循环列表，处于执行状态和等待执行的协程都处于列表中</p>
<h3 id="协程创建"><a href="#协程创建" class="headerlink" title="协程创建"></a>协程创建</h3><p>主要用于状态初始化，绑定对应的函数，加入到活动协程列表tasks中去。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">task_env *task_new(task_func func, task_arg arg, const char *name, int debug) &#123;</span><br><span class="line">  task_env *t;</span><br><span class="line">  if (link_empty(&amp;free_tasks))</span><br><span class="line">    t &#x3D; (task_env *)malloc(sizeof(task_env));</span><br><span class="line">  else</span><br><span class="line">    t &#x3D; container_of(link_extract_first(&amp;free_tasks), task_env, l);</span><br><span class="line">  IFDBG(D_NONE, FN; PTREXP(t); STREXP(name); NDBG(active_tasks, d););</span><br><span class="line">  task_init(t);</span><br><span class="line">  t-&gt;func &#x3D; func;</span><br><span class="line">  t-&gt;arg &#x3D; arg;</span><br><span class="line">  t-&gt;name &#x3D; name;</span><br><span class="line">  t-&gt;debug &#x3D; debug;</span><br><span class="line">  t-&gt;waitfd &#x3D; -1;</span><br><span class="line">  t-&gt;interrupt &#x3D; 0;</span><br><span class="line">  activate(t)&#123;</span><br><span class="line">      link_into(&amp;t-&gt;l, &amp;tasks);  &#x2F;&#x2F;tasks为可执行协程双向循环列表，tasks为列表的头结点， t加入到tasks的前面</span><br><span class="line">  &#125;</span><br><span class="line">  task_ref(t);</span><br><span class="line">  active_tasks++;</span><br><span class="line">  return t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="协程开始"><a href="#协程开始" class="headerlink" title="协程开始"></a>协程开始</h3><p>协程开始的过程如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#define TASK_BEGIN                                            \</span><br><span class="line"> </span><br><span class="line">  switch (stack-&gt;sp-&gt;state) &#123;                                 \</span><br><span class="line">    case 0:                                                   \</span><br><span class="line">      pushp(stack, TASK_ALLOC(stack, struct env));            \</span><br><span class="line">      ep &#x3D; _ep;                                               \</span><br><span class="line">      assert(ep);                                             \</span><br><span class="line">      TERM_CHECK;</span><br></pre></td></tr></table></figure>
<p>由于协程的运行机制为单线程模式，因此某一时刻只能有一个协程在运行，因此xcom设置一个全局变量stack，作为当前正在运行的协程栈，stack-&gt;sp-&gt;state为协程运行的位置，即代码的第几行，初始时设置为0，因此在协程被创建(task_new)第一次执行时，会进入switch语句的case 0 分支，首先会分为此协程分配栈帧，并且将该协程的运行环境上下文ep与全局变量_ep(stack-&gt;sp-&gt;ptr)绑定。因此在协程被挂起之前,运行过程一直处于switch 语句的case 0 分支内。</p>
<h3 id="协程挂起-YIELD"><a href="#协程挂起-YIELD" class="headerlink" title="协程挂起(YIELD)"></a>协程挂起(YIELD)</h3><p>当协程被挂起后会暂停执行，调度过程会切换到下一个活动的协程执行，协程从运行状态转化为挂起状态的过程如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#define TASK_YIELD                     \</span><br><span class="line">  &#123;                                    \</span><br><span class="line">    TASK_DEBUG(&quot;TASK_YIELD&quot;);          \</span><br><span class="line">    stack-&gt;sp-&gt;state &#x3D; __LINE__;       \</span><br><span class="line">    return 1;                          \</span><br><span class="line">    case __LINE__:                     \</span><br><span class="line">      TASK_DEBUG(&quot;RETURN FROM YIELD&quot;); \</span><br><span class="line">      ep &#x3D; _ep;                        \</span><br><span class="line">      assert(ep);                      \</span><br><span class="line">      TERM_CHECK;                      \</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>注意，在case <strong>LINE</strong> 语句之前的所有代码段都处于switch 的case 0 分支内，当调用 TASK_YIELD时，只需要保存当前协程的运行位置，即stack-&gt;sp-&gt;state = <strong>LINE</strong>， 如果下次协程被重新调度执行，那又会进行TASK_BEGIN过程内，此时会命中switch过程的 case <strong>LINE</strong> 位置，这样便可以接着上次挂起的位置继续执行，通过 ep = _ep 语句恢复一下运行上下文。</p>
<p>当一个协程被TASK_YIELD之后依然会处于活动协程队列tasks中，如果活动队列中没有其他的活动事务，可以又被执行；还有一种延迟执行的挂起方式，即首先将协程从活动队列中移除，按照延时设置的时间，放入task_time_q中相对位置（emmmm，比如一个函数设置延时为1秒，另一个为20秒，但是队列中只有着两个，则延迟20秒的会在延迟1秒的执行后立即执行），放入task_time_q中的协程只能通过task_wakeup等函数唤醒，加入到活动队列tasks中去。</p>
<p>此外，还有挂起当前协程的操作TASK_WAIT</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#define TASK_WAIT(queue)     \</span><br><span class="line">  &#123;                          \</span><br><span class="line">    TASK_DEBUG(&quot;TASK_WAIT&quot;); \</span><br><span class="line">    task_wait(stack, queue); \</span><br><span class="line">    TASK_YIELD;              \</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>本协程调用协程funcall，在funcall返回期望的返回值(0)之前，本协程一直挂起，并让出cpu，当funcall返回0后，本协程等调度后继续执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#define TASK_CALL(funcall)            \</span><br><span class="line">  &#123;                                   \</span><br><span class="line">    reset_state(stack);               \</span><br><span class="line">    TASK_DEBUG(&quot;BEFORE CALL&quot;);        \</span><br><span class="line">    do &#123;                              \</span><br><span class="line">      stack-&gt;sp--;                    \</span><br><span class="line">      stack-&gt;taskret &#x3D; funcall;       \</span><br><span class="line">      stack-&gt;sp++;                    \</span><br><span class="line">      TERM_CHECK;                     \</span><br><span class="line">      if (stack-&gt;taskret) TASK_YIELD; \</span><br><span class="line">    &#125; while (stack-&gt;taskret);         \</span><br><span class="line">    TASK_DEBUG(&quot;AFTER CALL&quot;);         \</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>本协程被deactivate，只有被重新active时才可以继续执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#define TASK_DEACTIVATE            \</span><br><span class="line">  &#123;                                \</span><br><span class="line">    TASK_DEBUG(&quot;TASK_DEACTIVATE&quot;); \</span><br><span class="line">    task_deactivate(stack);        \</span><br><span class="line">    TASK_YIELD;                    \</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


<h3 id="协程调度"><a href="#协程调度" class="headerlink" title="协程调度"></a>协程调度</h3><p>task_loop为协程管理器，只有当协程退出或者被decactive时，才从列表中删除。。当前活动的协程变量为全局变量stack，在协程YIELD时，会进行压栈操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">void task_loop() &#123;</span><br><span class="line">  task_env *t &#x3D; 0;</span><br><span class="line">  &#x2F;* While there are tasks *&#x2F;</span><br><span class="line">  for (;;) &#123;</span><br><span class="line">    &#x2F;* check forced exit callback *&#x2F;</span><br><span class="line">    if (get_should_exit()) &#123;</span><br><span class="line">      terminate_and_exit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    t &#x3D; first_runnable(); &#x2F;&#x2F; 获取双向循环列表中头结点的下一个结点，由于在task_new时在tasks中采用了前插的方法，即插入到tasks的尾部，因此此时获取最后插入的协程</span><br><span class="line">    &#x2F;&#x2F; 通过判断tasks是否为空判断是否有可以执行的协程</span><br><span class="line">    while (runnable_tasks()) &#123;</span><br><span class="line">      task_env *next &#x3D; next_task(t); &#x2F;&#x2F; 获取下一个</span><br><span class="line">      if (!is_task_head(t)) &#123; &#x2F;&#x2F; 不是tasks的头结点</span><br><span class="line">         &#x2F;*IFDBG(D_NONE, FN; PTREXP(t); STRLIT(t-&gt;name ? t-&gt;name : &quot;TASK WITH NO</span><br><span class="line">         * NAME&quot;)); *&#x2F;</span><br><span class="line">        stack &#x3D; t; &#x2F;&#x2F; 设置当前运行的协程栈为t</span><br><span class="line">        assert(stack);</span><br><span class="line">        assert(t-&gt;terminate !&#x3D; TERMINATED);</span><br><span class="line">        &#123;</span><br><span class="line">          &#x2F;* double when &#x3D; seconds(); *&#x2F;</span><br><span class="line">          int val &#x3D; 0;</span><br><span class="line">          assert(t-&gt;func);</span><br><span class="line">          assert(stack &#x3D;&#x3D; t);</span><br><span class="line">          val &#x3D; t-&gt;func(t-&gt;arg); &#x2F;&#x2F; 通过函数指针调用对应的协程，如果协程退出结束，返回0，如果协程只是暂时挂起，返回1</span><br><span class="line">          &#x2F;&#x2F;printf(&quot;corioutine change：%s\n&quot;,t-&gt;name);</span><br><span class="line">          &#x2F;&#x2F;fflush(stdout);</span><br><span class="line">          assert(ash_nazg_gimbatul.type &#x3D;&#x3D; TYPE_HASH(&quot;task_env&quot;));</span><br><span class="line">          if (!val) &#123; &#x2F;* 协程结束 *&#x2F;</span><br><span class="line">            deactivate(t); &#x2F;&#x2F; 调用link_out,将此协程从tasks中删除</span><br><span class="line">            t-&gt;terminate &#x3D; TERMINATED;</span><br><span class="line">            task_unref(t); &#x2F;&#x2F; 还会将协程从task all 列表中删除，active_tasks--</span><br><span class="line">            stack &#x3D; NULL; </span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      t &#x3D; next;</span><br><span class="line">    &#125;</span><br><span class="line">    if (active_tasks &lt;&#x3D; 0) break; &#x2F;&#x2F; 如果没有可以执行的协程的了，直接退出</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 如果可以运行到这里，代表tasks里没有了，但是active_tasks还大于0，需要等待休眠的协程被唤醒</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">      double time &#x3D; seconds();</span><br><span class="line">      if (delayed_tasks()) &#123;</span><br><span class="line">            .....</span><br><span class="line">          task_env *delayed_task &#x3D; extract_first_delayed(); &#x2F;* May be NULL *&#x2F;</span><br><span class="line">          if (delayed_task) activate(delayed_task); &#x2F;* Make it runnable *&#x2F;</span><br><span class="line">            .....</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  task_sys_deinit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-基于协程的paxos实现"><a href="#4-基于协程的paxos实现" class="headerlink" title="4. 基于协程的paxos实现"></a>4. 基于协程的paxos实现</h2><p>在xcom中，通过TASK_BEGIN, TASK_YIELD, TASK_DELAY,TASK_WAIT等过程进行协程的开始，挂起，休眠等操作。</p>
<p>xcom初始化时，会新建一系列活动协程，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">set_task(&amp;executor, task_new(executor_task, null_arg, &quot;executor_task&quot;,</span><br><span class="line">                             XCOM_THREAD_DEBUG));</span><br><span class="line">set_task(&amp;sweeper,</span><br><span class="line">         task_new(sweeper_task, null_arg, &quot;sweeper_task&quot;, XCOM_THREAD_DEBUG));</span><br><span class="line">set_task(&amp;detector, task_new(detector_task, null_arg, &quot;detector_task&quot;,</span><br><span class="line">                             XCOM_THREAD_DEBUG));</span><br><span class="line">set_task(&amp;alive_t,</span><br><span class="line">         task_new(alive_task, null_arg, &quot;alive_task&quot;, XCOM_THREAD_DEBUG));</span><br><span class="line">set_task(&amp;cache_task, task_new(cache_manager_task, null_arg,</span><br><span class="line">                               &quot;cache_manager_task&quot;, XCOM_THREAD_DEBUG));</span><br></pre></td></tr></table></figure>
<p>协程创建完成以后，便可以通过task_loop进行调度，以sweeper_task为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">static int sweeper_task(task_arg arg MY_ATTRIBUTE((unused))) &#123;</span><br><span class="line">  DECL_ENV</span><br><span class="line">  synode_no find;</span><br><span class="line">  END_ENV;</span><br><span class="line">  TASK_BEGIN</span><br><span class="line">  ep-&gt;find &#x3D; get_sweep_start();</span><br><span class="line">  &#x2F;&#x2F;printf(&quot;%lld,   %lld\n&quot;,(long long)ep-&gt;find.msgno, (long long)ep-&gt;find.node);</span><br><span class="line">  &#x2F;&#x2F;fflush(stdout);</span><br><span class="line">  while (!xcom_shutdown) &#123;</span><br><span class="line">        while (synode_lt(ep-&gt;find, max_synode) &amp;&amp; !too_far(ep-&gt;find)) &#123;</span><br><span class="line">            &#x2F;&#x2F;此处会进行判断本节点负责的消息需不需要skip操作</span><br><span class="line">            &#x2F;&#x2F;并进行对应的操作</span><br><span class="line">        &#125;</span><br><span class="line">  deactivate:</span><br><span class="line">    TASK_DEACTIVATE;</span><br><span class="line">  &#125;</span><br><span class="line">  TASK_END;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将宏全部展开后，整个函数变成由switch控制的结构，case 0 和case <strong>LINE</strong>决定了函数多次进入的时机，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">static int sweeper_task(task_arg arg MY_ATTRIBUTE((unused))) &#123;</span><br><span class="line">  struct env &#123;</span><br><span class="line">    synode_no find;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  struct env MY_ATTRIBUTE((unused)) * ep</span><br><span class="line">  switch (stack-&gt;sp-&gt;state) &#123; </span><br><span class="line">        case 0: </span><br><span class="line">            pushp(stack, TASK_ALLOC(stack, struct env)); </span><br><span class="line">            ep &#x3D; _ep; </span><br><span class="line">            assert(ep); </span><br><span class="line">            TERM_CHECK;</span><br><span class="line">            ep-&gt;find &#x3D; get_sweep_start();</span><br><span class="line">            </span><br><span class="line">            while (!xcom_shutdown) &#123;</span><br><span class="line">                while (synode_lt(ep-&gt;find, max_synode) &amp;&amp; !too_far(ep-&gt;find)) &#123;</span><br><span class="line">                    &#x2F;&#x2F;此处会进行判断本节点负责的消息需不需要skip操作</span><br><span class="line">                    &#x2F;&#x2F;并进行对应的操作</span><br><span class="line">                &#125;</span><br><span class="line">                deactivate:</span><br><span class="line">                    task_deactivate(stack);</span><br><span class="line">                    stack-&gt;sp-&gt;state &#x3D; __LINE__;       </span><br><span class="line">                    return 1;                          </span><br><span class="line">                case __LINE__:                     </span><br><span class="line">                   ep &#x3D; _ep;                        </span><br><span class="line">                   assert(ep);                      </span><br><span class="line">                   TERM_CHECK;  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    stack-&gt;sp-&gt;state &#x3D; 0;                                       </span><br><span class="line">    stack-&gt;where &#x3D; (TaskAlign *)stack-&gt;sp-&gt;ptr;                 </span><br><span class="line">    popp(stack);                                  </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-future"><a href="#5-future" class="headerlink" title="5. future"></a>5. future</h2><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><p><strong>多线程改造:</strong> 数据结构加锁，仿照协程机制进行线程之间的调用和同步；</p>
<p>借鉴x-paxos：<br>X-Paxos的服务层是一个基于C++ 11特性实现的多线程异步框架。常见的状态机/回调模型存在开发效率较低，可读性差等问题，一直被开发者所诟病;而协程又因其单线程的瓶颈，而使其应用场景受到限制。C++ 11以后的新版本提供了完美转发(argument forwarding)、可变模板参数(variadic templates)等特性，可以比较方便的实现异步调用模型。</p>
<p><strong>多组xcom</strong>：每组单线程，抽离xcom模块中视图变更、故障检测模块，统一封装gcs接口</p>
<p>借鉴 phxpaxos &amp;&amp; multi raft：<br>phxpaxos架构上采用单Paxos单线程设计，但是支持多Paxos分区以扩展多线程能力，其单分区单线程，多实例聚合的方式也提升总吞吐。</p>
<h2 id="6-简要介绍"><a href="#6-简要介绍" class="headerlink" title="6. 简要介绍"></a>6. 简要介绍</h2><p>xcom可以保证消息在所有节点上以相同的顺序接收，还可以保证，如果一条消息被传递到一个节点，那么它最终也会在所有其他节点上看到。如果至少有一个知道消息值的节点没有崩溃，当崩溃的节点恢复时，xcom可以在这个崩溃的节点上恢复消息。日志记录可以添加到磁盘，以使消息在系统崩溃时持久化，以增加可以缓存的消息数量。但是xcom不能保证来自不同节点的消息顺序，甚至不能保证来自同一节点的多个消息的顺序。只有由客户机在发送下一条消息之前等待一条消息才能保证这样结果。xcom可以通知客户端消息已超时，在这种情况下，xcom将尝试取消消息，但它不能保证不会传递超时的消息。xcom在每个消息传递到客户机时为其附加一个节点集。这个节点集反映了xcom认为是活动的当前节点集，并不意味着消息已经传递到集合中的所有节点。也不意味着消息没有被传递到不在集合中的节点。Paxos状态机的每个实例实现基本的Paxos协议。paxos消息的缓存是一个经典的固定大小的LRU，具有哈希索引。</p>
<p>已经实现了部分mencius算法，主要包括simple paxos部分：</p>
<p>一个节点拥有其自身节点号的所有synode的所有权。只有节点号为N的节点才能为synode{X,N}提出一个值，其中X是序列号，N是节点号。其他节点只能为synode{X,N}提出特殊值no_op。这样做的原因是保留了无领导的Paxos算法，但避免了竞争同一个synode数的节点之间的冲突。在这个方案中，每个节点在正常运行时都有自己唯一的数序列。该方法具有以下含义：</p>
<ol>
<li><p>如果一个节点N还没有为synode{X,N}提出一个值，它可以在任何时候用保留值no_op向其他节点发送学习消息，而不经过Paxos的第1和第2阶段。这是因为其他节点都被限制为不建议这个概要，所以最终的结果始终是no-op，为了避免不必要的消息传输，一个节点将尝试通过携带基本Paxos协议消息上的信息来广播no_op学习消息。</p>
</li>
<li><p>其他想要找到synode{X,N}值的节点可以通过遵循基本的Paxos算法来获得不可接受的值。结果将是node N提出的实际值（如果它已经提议了），否则最终结果只能是no_op。这通常只在一个节点关闭时才需要，而其他节点需要从丢失的节点中查找值，以便能够继续执行。</p>
</li>
</ol>
<p>消息按顺序发送到客户端，顺序由序列号和节点号决定，序列号是最重要的部分。</p>
<p>xcom模块主要使用以下术语：</p>
<p>节点是xcom线程的实例。代理中只有一个xcom线程实例。</p>
<p>客户机是使用xcom发送消息的应用程序。</p>
<p>线程是真正的操作系统线程。</p>
<p>task是一个逻辑过程。它由协程和显式堆栈实现。task和非阻塞套接字操作的实现在task.h和task.c中是隔离的。</p>
<p>一个节点将打开到其他每个节点的tcp连接。此连接用于节点启动的所有通信，对消息的答复将到达发送消息的连接上。</p>
<p>xcom中主要协程如下：</p>
<p>static int tcp_server(task_arg);</p>
<p>tcp_server监听xcom端口，并在检测到新连接时启动acceptor_learner_task协程。</p>
<p>static int tcp_reaper_task(task_arg);<br>用于当一个tcp连接长时间被占用时被关闭</p>
<p>static int sender_task(task_arg);</p>
<p>sender_task在其输入队列上等待tcp消息，并在tcp套接字上发送它。如果套接字因任何原因关闭，sender_task将重新连接socket。每个socket都有一个sender_task。sender_task主要是为了简化其他任务中的逻辑，但是它可以被一个协程所取代，该协程在为其client 的task保留了套接字之后处理连接逻辑。<br>其从队列中获取消息并发送到其他服务器。使用一个单独的队列和任务来执行此操作简化了逻辑，因为其他的task不需要等待发送。</p>
<p>static int generator_task(task_arg);</p>
<p>generator_task从客户机队列读取消息，并将其移动到proposer_task的输入队列中</p>
<p>static int proposer_task(task_arg);</p>
<p>为传入的消息分配一个消息编号，并尝试使其被接受。每个节点上可能有多个proposer tasks并行工作。如果有多个proposer tasks，xcom不能保证消息将按照从客户端接收的相同顺序发送。</p>
<p>static int acceptor_learner_task(task_arg);</p>
<p>这是xcom线程的服务部分。系统中的每个节点都有一个acceptor_learner_task。acceptor learner_任务从套接字读取消息，找到正确的Paxos状态机，并将状态机和消息作为参数发送到正确的消息处理程序。</p>
<p>static int reply_handler_task(task_arg);</p>
<p>reply_handler_task执行与acceptor_learner_task相同的工作，但侦听节点用于发送消息的套接字，因此它将仅处理该套接字上的回复。</p>
<p>static int executor_task(task_arg);</p>
<p>ececutor_task等待接收Paxos消息。当消息被接受时，它被传递到客户端，除非它是一个no-op。在任何一种情况下，executor_task都会进入下一条消息并重复等待。如果等待消息超时，它将尝试接受一个no-op。</p>
<p>static int alive_task(task_arg);</p>
<p>如果有一段时间没有正常通信，则向其他节点发送i-am-alive。它还ping似乎不活动的节点。</p>
<p>static int detector_task(task_arg);</p>
<p>detector_task定期扫描来自其他节点的连接集合，并查看是否存在任何活动。如果有一段时间没有活动，它将假定节点已经宕机，并向客户机发送一条视图变更消息。</p>
<p>重新配置：</p>
<p>xcom重新配置的过程借鉴Lamport在“Reconfiguring a State Machine” 论文中描述的过程， 以此作为R-alpha算法。xcom会立即执行重新配置命令，但是配置只有在alpha消息的延迟之后才有效。</p>
<p>##temp notes</p>
<h3 id="pax-machine-缓存机制："><a href="#pax-machine-缓存机制：" class="headerlink" title="pax machine 缓存机制："></a>pax machine 缓存机制：</h3><p>缓存机制的整个缓存结构由以下方式组织:总的数据结构为hash_stack, 由节点类型为stack_machine按照linkage方式构成的双向循环链表，每个stack_machine由维护了一个hash表pax_hash, pax_hash由数据类型为pax_machine链表构成的数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct stack_machine &#123;</span><br><span class="line">  linkage stack_link;</span><br><span class="line">  uint64_t start_msgno;</span><br><span class="line">  uint occupation;</span><br><span class="line">  linkage *pax_hash;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Paxos machine cache *&#x2F;</span><br><span class="line">struct lru_machine &#123;</span><br><span class="line">  linkage lru_link;</span><br><span class="line">  pax_machine pax;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>缓存模块以静态分配的方式分配 pax_machine cache, 除了保存pax_machine的hash_stack之外，还有protected_lru:按照最近使用的顺序跟踪正在使用的pax machine；probation_lru：空闲的列表。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static linkage hash_stack &#x3D; &#123;0, &amp;hash_stack,</span><br><span class="line">                             &amp;hash_stack&#125;; &#x2F;* hash stack 的头结点*&#x2F;</span><br><span class="line">static linkage protected_lru &#x3D; &#123;</span><br><span class="line">    0, &amp;protected_lru, &amp;protected_lru&#125;; &#x2F;* 最近使用链表的头结点 *&#x2F;</span><br><span class="line">static linkage probation_lru &#x3D; &#123;</span><br><span class="line">    0, &amp;probation_lru, &amp;probation_lru&#125;; &#x2F;* 空闲链表的头结点 *&#x2F;</span><br></pre></td></tr></table></figure>
<p>按照消息号获取对应pax_machine时，首先在hash_stack中找到对应的stack_machine, 然后在这个stack_machine的hash表pax_hash中找到对应的pax_nachine,过程如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">pax_machine *hash_get(synode_no synode) &#123;</span><br><span class="line">  &#x2F;* static pax_machine *cached_machine &#x3D; NULL; *&#x2F;</span><br><span class="line">  stack_machine *hash_table &#x3D; NULL;</span><br><span class="line"></span><br><span class="line">  &#x2F;* if(cached_machine &amp;&amp; synode_eq(synode, cached_machine-&gt;synode)) *&#x2F;</span><br><span class="line">  &#x2F;* return cached_machine; *&#x2F;</span><br><span class="line"></span><br><span class="line">  FWD_ITER(&amp;hash_stack, stack_machine, &#123;</span><br><span class="line">    &#x2F;* 在hash_stack 中寻找比synode号小或者等于0的instance*&#x2F;</span><br><span class="line">    if (link_iter-&gt;start_msgno &lt; synode.msgno || link_iter-&gt;start_msgno &#x3D;&#x3D; 0) &#123;</span><br><span class="line">      hash_table &#x3D; link_iter;</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  if (hash_table !&#x3D; NULL) &#123;</span><br><span class="line">    linkage *bucket &#x3D; &amp;hash_table-&gt;pax_hash[synode_hash(synode)];</span><br><span class="line"></span><br><span class="line">    FWD_ITER(bucket, pax_machine, &#123;</span><br><span class="line">      if (synode_eq(link_iter-&gt;synode, synode)) &#123;</span><br><span class="line">        &#x2F;* cached_machine &#x3D; link_iter; *&#x2F;</span><br><span class="line">        return link_iter;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中宏 FWD_ITER 为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Forward iterator *&#x2F;</span><br><span class="line">&#x2F;* 当前节点开始，向后遍历，因为是双向循环链表，总会回到自身 *&#x2F;</span><br><span class="line">#define FWD_ITER(head, type, action)                      \</span><br><span class="line">  &#123;                                                       \</span><br><span class="line">    linkage *p &#x3D; link_first(head);                        \</span><br><span class="line">    while (p !&#x3D; (head)) &#123;                                 \</span><br><span class="line">      linkage *_next &#x3D; link_first(p);                     \</span><br><span class="line">      &#123;                                                   \</span><br><span class="line">        type *link_iter &#x3D; (type *)p;                      \</span><br><span class="line">        (void)link_iter;                                  \</span><br><span class="line">        action;                                           \</span><br><span class="line">      &#125; &#x2F;* Cast to void avoids unused variable warning *&#x2F; \</span><br><span class="line">      p &#x3D; _next;                                          \</span><br><span class="line">    &#125;                                                     \</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>hash_get中第一个FWD_ITER可以展开为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">linkage *p &#x3D; link_first(&amp;hash_stack);</span><br><span class="line">    while (p !&#x3D; (&amp;hash_stack)) &#123; </span><br><span class="line">        linkage *_next &#x3D; link_first(p); </span><br><span class="line">        &#123; </span><br><span class="line">            stack_machine *link_iter &#x3D; (stack_machine *)p; &#x2F;&#x2F; linkage类型转化为对应的stack_machine类型</span><br><span class="line">            (void)link_iter; </span><br><span class="line">            &#123; </span><br><span class="line">                if (link_iter-&gt;start_msgno &lt; synode.msgno ||link_iter-&gt;start_msgno &#x3D;&#x3D; 0) &#123; </span><br><span class="line">                    hash_table &#x3D; link_iter;</span><br><span class="line">                    break; </span><br><span class="line">                &#125; </span><br><span class="line">            &#125;;</span><br><span class="line">        &#125; </span><br><span class="line">        p &#x3D; _next; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在缓存中查找对应消息号的pax machine 时，如果找不到，首先从probation_lru(空闲链表)中查找下一个空闲节点，如果找不到空闲节点，将会从protected_lru中寻找空闲状态的的pax machine，优先从空闲状态的实例取出已经被执行过的节点(通过deliverd_msg判断， deliverd_msg是已经提交给上层客户端的最新消息号，因此比其小的消息都是可以被清理掉的)，如果将force参数设置为了true，那么只要是空闲的pax_machine 不管有没有被提交到上层客户端，就会被抢占。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">pax_machine *get_cache_no_touch(synode_no synode, bool_t force) &#123;</span><br><span class="line">  pax_machine *retval &#x3D; hash_get(synode);</span><br><span class="line">  &#x2F;* IFDBG(D_NONE, FN; SYCEXP(synode); STREXP(task_name())); *&#x2F;</span><br><span class="line">  IFDBG(D_NONE, FN; SYCEXP(synode); PTREXP(retval));</span><br><span class="line">  if (!retval) &#123;</span><br><span class="line">    lru_machine *l &#x3D;</span><br><span class="line">        lru_get(force); &#x2F;* Need to know when it is safe to re-use... *&#x2F;</span><br><span class="line">    if (!l) return NULL;</span><br><span class="line">    IFDBG(D_NONE, FN; PTREXP(l); COPY_AND_FREE_GOUT(dbg_pax_machine(&amp;l-&gt;pax)););</span><br><span class="line">    &#x2F;* assert(l-&gt;pax.synode &gt; log_tail); *&#x2F;</span><br><span class="line"></span><br><span class="line">    retval &#x3D; hash_out(&amp;l-&gt;pax);          &#x2F;* 从hash表中删除 *&#x2F;</span><br><span class="line">    init_pax_machine(retval, l, synode); &#x2F;* Initialize *&#x2F;</span><br><span class="line">    hash_in(retval);                     &#x2F;* Insert in hash table again *&#x2F;</span><br><span class="line">  &#125;</span><br><span class="line">  IFDBG(D_NONE, FN; SYCEXP(synode); PTREXP(retval));</span><br><span class="line">  return retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="协程启动过程"><a href="#协程启动过程" class="headerlink" title="协程启动过程"></a>协程启动过程</h3><p>以proposer_task为例，查看协程的启动过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#0  proposer_task (arg&#x3D;...)</span><br><span class="line">    at &#x2F;home&#x2F;zhaoguodong&#x2F;msBuild&#x2F;mysql-8.0.22&#x2F;plugin&#x2F;group_replication&#x2F;libmysqlgcs&#x2F;src&#x2F;bindings&#x2F;xcom&#x2F;xcom&#x2F;xcom_base.cc:1817</span><br><span class="line">#1  0x00007fff8cbea9d5 in task_loop ()</span><br><span class="line">    at &#x2F;home&#x2F;zhaoguodong&#x2F;msBuild&#x2F;mysql-8.0.22&#x2F;plugin&#x2F;group_replication&#x2F;libmysqlgcs&#x2F;src&#x2F;bindings&#x2F;xcom&#x2F;xcom&#x2F;task.cc:1133</span><br><span class="line">#2  0x00007fff8cb8b760 in xcom_taskmain2 (listen_port&#x3D;24903)</span><br><span class="line">    at &#x2F;home&#x2F;zhaoguodong&#x2F;msBuild&#x2F;mysql-8.0.22&#x2F;plugin&#x2F;group_replication&#x2F;libmysqlgcs&#x2F;src&#x2F;bindings&#x2F;xcom&#x2F;xcom&#x2F;xcom_base.cc:1279</span><br><span class="line">#3  0x00007fff8cb70ace in Gcs_xcom_proxy_impl::xcom_init (this&#x3D;0x7fff38027e10, xcom_listen_port&#x3D;24903)</span><br><span class="line">    at &#x2F;home&#x2F;zhaoguodong&#x2F;msBuild&#x2F;mysql-8.0.22&#x2F;plugin&#x2F;group_replication&#x2F;libmysqlgcs&#x2F;src&#x2F;bindings&#x2F;xcom&#x2F;gcs_xcom_proxy.cc:185</span><br><span class="line">#4  0x00007fff8cc1455e in xcom_taskmain_startup (ptr&#x3D;0x7fff3800f9b0)</span><br><span class="line">    at &#x2F;home&#x2F;zhaoguodong&#x2F;msBuild&#x2F;mysql-8.0.22&#x2F;plugin&#x2F;group_replication&#x2F;libmysqlgcs&#x2F;src&#x2F;bindings&#x2F;xcom&#x2F;gcs_xcom_control_interface.cc:102</span><br><span class="line">#5  0x000055555a809a7c in pfs_spawn_thread (arg&#x3D;0x7fff380229e0)</span><br><span class="line">    at &#x2F;home&#x2F;zhaoguodong&#x2F;msBuild&#x2F;mysql-8.0.22&#x2F;storage&#x2F;perfschema&#x2F;pfs.cc:2880</span><br><span class="line">#6  0x00007ffff7bbd6db in start_thread (arg&#x3D;0x7fff2b7fe700) at pthread_create.c:463</span><br><span class="line">#7  0x00007ffff613aa3f in clone () at ..&#x2F;sysdeps&#x2F;unix&#x2F;sysv&#x2F;linux&#x2F;x86_64&#x2F;clone.S:95</span><br></pre></td></tr></table></figure>


<p>在xcom_taskmain_startup 主要有以下过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Gcs_xcom_proxy *proxy &#x3D; gcs_ctrl-&gt;get_xcom_proxy();</span><br><span class="line"></span><br><span class="line">proxy-&gt;set_should_exit(false);</span><br><span class="line"></span><br><span class="line">proxy-&gt;xcom_init(port); &#x2F;&#x2F; 开启一个新的线程用于xcom初始化</span><br></pre></td></tr></table></figure>
<p>当xcom初始化失败时会不停的重新建立新的线程用于xcom模块。</p>
<p>在xcom_init中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">::xcom_fsm(x_fsm_init, int_arg(0)); &#x2F;&#x2F; 用于</span><br><span class="line"></span><br><span class="line">  ::xcom_taskmain2(xcom_listen_port);</span><br></pre></td></tr></table></figure>

<p>在 xcom_taskmain2中,注册tcp_server协程来监听socket服务器端连接，每当有新的连接进来，就会创建一个acceptor_learner_task协程来处理该连接的后续消息。task_loop作为协程管理器，会时刻检测可以执行的协程，并使其执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">task_new(tcp_server, int_arg(tcp_fd.val), &quot;tcp_server&quot;, XCOM_THREAD_DEBUG); &#x2F;&#x2F; 注册tcp_server协程来监听socket服务器端连接</span><br><span class="line">task_new(tcp_reaper_task, null_arg, &quot;tcp_reaper_task&quot;, XCOM_THREAD_DEBUG);</span><br><span class="line"></span><br><span class="line">task_loop(); &#x2F;&#x2F; 会循环不停的进行协程的切换和运行</span><br></pre></td></tr></table></figure>
<p>在tcp_server 协程中，主要逻辑如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int tcp_server(task_arg arg) &#123;</span><br><span class="line"></span><br><span class="line">  G_MESSAGE(</span><br><span class="line">      &quot;XCom initialized and ready to accept incoming connections on port %d&quot;,</span><br><span class="line">      xcom_listen_port);</span><br><span class="line">  do &#123;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 调用accept_tcp协程，等待新的连接到来</span><br><span class="line">    TASK_CALL(accept_tcp(ep-&gt;fd, &amp;ep-&gt;cfd));</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; acceptor_learner_task协程来处理该连接的后续消息</span><br><span class="line">    task_new(acceptor_learner_task, int_arg(ep-&gt;cfd), &quot;acceptor_learner_task&quot;, XCOM_THREAD_DEBUG);</span><br><span class="line">  &#125; while (!xcom_shutdown &amp;&amp; (ep-&gt;cfd &gt;&#x3D; 0 || ep-&gt;refused));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>task_loop作为整个协程机制的调度器，主要通过循环的方式从协程栈中恢复协程上下文，调度等待执行的协程继续执行,在 task_loop中，主要逻辑如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">for (;;) &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F; 获取可以执行的task</span><br><span class="line">    t &#x3D; first_runnable();</span><br><span class="line">    while (runnable_tasks()) &#123;</span><br><span class="line">      &#x2F;&#x2F; 获取下一个可以执行的协程</span><br><span class="line">      task_env *next &#x3D; next_task(t);</span><br><span class="line">      if (!is_task_head(t)) &#123;</span><br><span class="line">        &#123;</span><br><span class="line">          val &#x3D; t-&gt;func(t-&gt;arg);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      t &#x3D; next;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>























      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
        <div class="declare">
          <ul class="post-copyright">
            <li>
              <i class="ri-copyright-line"></i>
              <strong>版权声明： </strong s>
              本博客所有文章除特别声明外，均采用 <a href="https://www.apache.org/licenses/LICENSE-2.0.html" rel="external nofollow"
                target="_blank">Apache License 2.0</a> 许可协议。转载请注明出处！
            </li>
          </ul>
        </div>
        
    <footer class="article-footer">
      
          
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://yoursite.com/2021/01/27/mysql%20MGR%20%E7%A0%94%E7%A9%B6%E4%B9%8Bpaxos%E5%AE%9E%E7%8E%B0-xcom%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/distribute/" rel="tag">distribute</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/fault-tolerance/" rel="tag">fault tolerance</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/system/" rel="tag">system</a></li></ul>


    </footer>

  </div>

  
  
  <nav class="article-nav">
    
      <a href="/2021/03/04/Mysql-mgr-%E9%80%89%E4%B8%BB%E4%BC%98%E5%8C%96/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            Mysql Mgr模块研究之孟子协议实现：xcom模块
          
        </div>
      </a>
    
    
      <a href="/2020/07/23/PostgreSQL%20%E5%86%85%E6%A0%B8%20learning/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">PostgreSQL内核分析教程</div>
      </a>
    
  </nav>


  

  
  
<!-- valine评论 -->
<div id="vcomments-box">
    <div id="vcomments">
    </div>
</div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='https://cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js'></script>
<script>
    new Valine({
        el: '#vcomments',
        app_id: '',
        app_key: '',
        path: window.location.pathname,
        notify: 'false',
        verify: 'false',
        avatar: 'mp',
        placeholder: '给我的文章加点评论吧~',
        recordIP: true
    });
    const infoEle = document.querySelector('#vcomments .info');
    if (infoEle && infoEle.childNodes && infoEle.childNodes.length > 0) {
        infoEle.childNodes.forEach(function (item) {
            item.parentNode.removeChild(item);
        });
    }
</script>
<style>
    #vcomments-box {
        padding: 5px 30px;
    }

    @media screen and (max-width: 800px) {
        #vcomments-box {
            padding: 5px 0px;
        }
    }

    #vcomments-box #vcomments {
        background-color: #fff;
    }

    .v .vlist .vcard .vh {
        padding-right: 20px;
    }

    .v .vlist .vcard {
        padding-left: 10px;
    }
</style>

  

  
  
  

</article>
</section>
      <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>
        &copy;
        2015-2021
        John Doe
      </li>
      <li>
        
      </li>
    </ul>
    <ul class="list-inline">
      <li>
        
        
        <span>
  <i>PV:<span id="busuanzi_value_page_pv"></span></i>
  <i>UV:<span id="busuanzi_value_site_uv"></span></i>
</span>
        
      </li>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>
    <div class="to_top">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>
      </div>
    </main>
      <aside class="sidebar">
        <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="babalalala"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
      </aside>
      <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
      
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script src="/js/busuanzi-2.3.pure.min.js"></script>


<script src="/js/share.js"></script>



<script src="/fancybox/jquery.fancybox.min.js"></script>




<script>
  try {
    var typed = new Typed("#subtitle", {
    strings: ['面朝大海，春暖花开','愿你一生努力，一生被爱','想要的都拥有，得不到的都释怀'],
    startDelay: 0,
    typeSpeed: 200,
    loop: true,
    backSpeed: 100,
    showCursor: true
    });
  } catch (err) {
  }
  
</script>




<script src="/js/tocbot.min.js"></script>

<script>
  // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer:'main',
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto',
    onClick: (e) => {
      $('.toc-link').removeClass('is-active-link');
      $(`a[href=${e.target.hash}]`).addClass('is-active-link');
      $(e.target.hash).scrollIntoView();
      return false;
    }
  });
</script>


<script>
  var ayerConfig = {
    mathjax: true
  }
</script>


<script src="/js/ayer.js"></script>


<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>



<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.6/unpacked/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>


<script type="text/javascript" src="https://js.users.51.la/20544303.js"></script>
  </div>
</body>

</html>